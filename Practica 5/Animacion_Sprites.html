<!DOCTYPE HTML>
<html>
<head>
  <title>Mi Escena de Sprites</title>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
</head>
   <body>
      <h2>Animacion con Sprites</h2>
      <canvas id="webglcanvas" style="border: 1px solid white;" width="800" height="600"></canvas>
      
      <img src="fondo.png" id="fondo_escena" hidden />
      <img src="snow-expansion.png" id="fondo_nieve" hidden />
      <img src="personajes.png" id="hoja_sprites" hidden />

      <script id="vs" type="vertex">
        #version 300 es
        precision mediump float;
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;
        uniform mat4 uMatrizTextura; 
        layout(location = 0) in vec2 aVertices;
        layout(location = 1) in vec2 aCoordenadasDeTextura;
        out vec2 vCoordenadasDeTextura;
        void main() {
            vCoordenadasDeTextura = (uMatrizTextura * vec4(aCoordenadasDeTextura, 0.0, 1.0)).xy;
            gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
        }
      </script>

      <script id="fs" type="fragment">
        #version 300 es
        precision mediump float;
        uniform sampler2D uUnidadDeTextura;
        in vec2 vCoordenadasDeTextura;
        out vec4 color;
        void main() {
            color = texture(uUnidadDeTextura, vCoordenadasDeTextura); 
            if (color.a == 0.0 || (color.r < 0.01 && color.g < 0.01 && color.b < 0.01)) {
                discard;
            }
        }
      </script>
	
      <script>
        'use strict';

        /* Variables globales */
        let gl, programaID, rectanguloVAO;
        let texFondo, texPersonajes, texNieve;
        let uMatrizProyeccion, uMatrizVista, uMatrizModelo, uUnidadDeTextura, uMatrizTextura;
        
        let MatrizProyeccion = new Array(16);
        let MatrizVista = new Array(16);
        let MatrizModelo = new Array(16);
        let MatrizTextura = new Array(16);
        
        let frameCounter = 0; 
        const totalTexCols = 12.0, totalTexRows = 8.0;
        const snowCols = 22.0, snowRows = 16.0;

        /* Estatua animada */
        let statueState = 0, statueCooldown = 0;
        const statueSprites = [
            { x: 16.1, y: 1 }, { x: 17.35, y: 1 }, { x: 18.60, y: 1 }
        ];
        const statueWidth = 1.0, statueHeight = 2.2;
        const statuePosX = 3.60, statuePosY = 0.65;

        /* Direcciones */
        const dir_abajo = 3, dir_izquierda = 2, dir_derecha = 1, dir_arriba = 0;

        /* P1 (Mago Azul) y P2 (Mago Verde) */
        let p1_posX = -1.4, p2_posX = -3.6;
        let p1_moveDir = -1, p2_moveDir = 1;
        const p_limit_left = -3.6, p_limit_right = -1.4, p_speed = 0.02;
        let isSnowy = false, collisionCooldown = 0;

        /* P3 (Bruja Rosa) */
        const p3_waypoints = [
            { x: 4.10, y: -2.10 }, { x: 4.10, y: -1.10 }, { x: 3.60, y: -1.10 },
            { x: 3.60, y: -0.02 }, { x: 3.60, y: -1.10 }, { x: 2.60, y: -1.10 },
            { x: 2.60, y: -2.10 }, { x: 4.10, y: -2.10 }
        ];
        let p3_state = {
            targetIndex: 1, posX: p3_waypoints[0].x, posY: p3_waypoints[0].y,
            dir: dir_arriba, moveDirX: 0, moveDirY: 1, animado: true,
            isPaused: false, pauseTimer: 0, hopOffset: 0.0
        };
        const p3_pauseDuration = 120;

        /* P4 (Bruja Naranja) */
        const p4_waypoints = [
          { x: 0.30, y: 0.20 }, { x: 1.30, y: 0.20 }, { x: 1.30, y: 0.60 },
          { x: 2.92, y: 0.60 }, { x: 1.30, y: 0.60 }, { x: -0.85, y: 0.60 },
          { x: -0.85, y: 1.25 }, { x: 0.30, y: 1.25 }, { x: 1.30, y: 1.25 },
          { x: 1.30, y: 1.65 }, { x: 0.30, y: 1.65 }, { x: 0.30, y: 1.25 },
          { x: -0.85, y: 1.25 }, { x: -0.85, y: 0.20 }, { x: 0.30, y: 0.20 }
        ];
        let p4_state = {
            targetIndex: 1, posX: p4_waypoints[0].x, posY: p4_waypoints[0].y,
            dir: dir_derecha, moveDirX: 1, moveDirY: 0, animado: true,
            isPaused: false, pauseTimer: 0
        };
        const p4_pauseDuration = 60;

        /* P6 (Mago Rojo Oscuro) */
        let p6_posX = -0.9, p6_posY = -0.8, p6_targetX = -2.2;
        let p6_moveDir = -1, p6_dir = dir_derecha;
        let p6_isPaused = true, p6_pauseTimer = 120;
        const p6_pauseDuration = 120, p6_limit_left = -3.0, p6_limit_right = -0.9, p6_stairs_X = -2.2;

        /***************************************************************************/
        /* Se crean, compilan y enlazan los programas Shader                       */
        /***************************************************************************/
        function compilaEnlazaLosShaders() {
          let shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
          gl.compileShader(shaderDeVertice);
          if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
             console.error(gl.getShaderInfoLog(shaderDeVertice)); return;
          }
          let shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
          gl.compileShader(shaderDeFragmento);
          if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) {
             console.error(gl.getShaderInfoLog(shaderDeFragmento)); return;
          }
          programaID = gl.createProgram();
          gl.attachShader(programaID, shaderDeVertice); 
          gl.attachShader(programaID, shaderDeFragmento);
          gl.linkProgram(programaID);
          if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
             console.error(gl.getProgramInfoLog(programaID)); return;
          }
        }

        /***************************************************************************/
        /* Transformaciones mediante matrices                                      */
        /***************************************************************************/
        function identidad(r) {
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }
                
        function traslacion(matriz, tx, ty, tz) {
          let r = new Array(16);
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }

        function escalacion(matriz, sx, sy, sz) { 
          let r = new Array(16);
          r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
          r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
          r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }
        
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
          r[0] = 2/(der - izq); r[4] =             0; r[ 8] =                  0; r[12] =         -(der + izq)/(der - izq);
          r[1] =             0; r[5] = 2/(arr - abj); r[ 9] =                  0; r[13] =         -(arr + abj)/(arr - abj);
          r[2] =             0; r[6] =             0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
          r[3] =             0; r[7] =             0; r[11] =                  0; r[15] =                                1;
        }

        function multiplica(c, a, b) {
          let r = new Array(16);
          let i, j, k;
          for (i = 0; i < 4; i++){
            for (j = 0; j < 4; j++){
              let s = 0;
              for (k = 0; k < 4; k++)
                s = s + a[i + k * 4] * b[k + j * 4];
                r[i + j * 4] = s;
              }
            }
          for (i = 0; i < 16; i++)
            c[i] = r[i];
        }

        function creaGeometriaRectangulo(gl) {
            let vertices = [ -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5 ];
            let coord_textura = [ 0, 0, 1, 0, 1, 1, 0, 1 ];
            rectanguloVAO = gl.createVertexArray();
            gl.bindVertexArray(rectanguloVAO);
            let codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0); 
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            let codigoCoordenadasDeTextura = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoCoordenadasDeTextura);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coord_textura), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);
            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }

        /***************************************************************************/
        /* Lee la Textura                                                          */
        /***************************************************************************/
        function leeLaTextura(gl, ID_del_archivo) {
          let codigoDeTextura = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, codigoDeTextura); 
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          let imagen = document.getElementById(ID_del_archivo);
          if (!imagen) {
              console.error("Error: No se encontró la imagen con ID: " + ID_del_archivo);
              return null;
          }
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imagen);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.bindTexture(gl.TEXTURE_2D, null);
          return codigoDeTextura;
        }

        // Actualizar el objetivo y dirección de movimiento de P3 y P4
        function setNewTarget(state, waypoints) {
            let newTarget = waypoints[state.targetIndex];
            let new_dx = newTarget.x - state.posX;
            let new_dy = newTarget.y - state.posY;

            if (Math.abs(new_dx) > Math.abs(new_dy)) {
                state.moveDirX = Math.sign(new_dx);
                state.moveDirY = 0;
                state.dir = (state.moveDirX > 0) ? dir_derecha : dir_izquierda;
            } else {
                state.moveDirX = 0;
                state.moveDirY = Math.sign(new_dy);
                state.dir = (state.moveDirY > 0) ? dir_arriba : dir_abajo;
            }
            state.animado = true;
        }

        // Aux - Capturar coordenadas del mouse
        function setupMouseCoordinates(gl) {
            let canvas = gl.canvas; 
            let aspect = canvas.width / canvas.height; 
            let mundoX = 5.0, mundoY = mundoX / aspect; 
            canvas.addEventListener('click', function(event) {
                let rect = canvas.getBoundingClientRect();
                let mouseX_px = event.clientX - rect.left;
                let mouseY_px = event.clientY - rect.top;
                let percentX = mouseX_px / canvas.width;
                let percentY = mouseY_px / canvas.height;
                let worldX = (percentX * (mundoX * 2)) - mundoX;
                let worldY = mundoY - (percentY * (mundoY * 2));
                console.log(`Coordenadas: X: ${worldX.toFixed(2)}, Y: ${worldY.toFixed(2)}`);
            });
        }

        /* Dibujar tiles de decoración */
        function dibujarTile(posX, posY, baseX, baseY, width, height, scaleX, scaleY) {
            gl.enable(gl.BLEND);
            gl.bindTexture(gl.TEXTURE_2D, texNieve);
            identidad(MatrizModelo);
            traslacion(MatrizModelo, posX, posY, 0);
            escalacion(MatrizModelo, scaleX, scaleY, 1.0);
            gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
            identidad(MatrizTextura);
            traslacion(MatrizTextura, baseX / snowCols, baseY / snowRows, 0);
            escalacion(MatrizTextura, width / snowCols, height / snowRows, 1.0);
            gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        }

        /***************************************************************************/
        /* Se renderizan todos los objetos                                         */
        /***************************************************************************/
        function dibuja() {
          gl.clear(gl.COLOR_BUFFER_BIT);
          frameCounter++; 
          gl.bindVertexArray(rectanguloVAO);
          gl.activeTexture(gl.TEXTURE0);

          /* Lógica P1 y P2 */
          if (collisionCooldown > 0) collisionCooldown--;
          p1_posX += p_speed * p1_moveDir;
          let p1_dir_anim = (p1_moveDir === 1) ? dir_derecha : dir_izquierda;
          if (p1_posX <= p_limit_left) p1_moveDir = 1;
          if (p1_posX >= p_limit_right) p1_moveDir = -1;
          
          p2_posX += p_speed * p2_moveDir;
          let p2_dir_anim = (p2_moveDir === 1) ? dir_derecha : dir_izquierda;
          if (p2_posX <= p_limit_left) p2_moveDir = 1;
          if (p2_posX >= p_limit_right) p2_moveDir = -1;
          
          if (Math.abs(p1_posX - p2_posX) < 0.2 && collisionCooldown === 0) {
              isSnowy = !isSnowy; 
              collisionCooldown = 100; 
              p1_moveDir *= -1;
              p2_moveDir *= -1;
          }

          /* Lógica P3 (Bruja Rosa) */
          p3_state.hopOffset = 0.0;
          if (p3_state.isPaused) {
              p3_state.pauseTimer--;
              if (p3_state.pauseTimer <= 0) {
                  p3_state.isPaused = false;
                  p3_state.targetIndex = 4;
                  setNewTarget(p3_state, p3_waypoints);
              }
          } else {
              p3_state.posX += (p_speed-0.005) * p3_state.moveDirX;
              p3_state.posY += (p_speed-0.005) * p3_state.moveDirY;
              p3_state.hopOffset = Math.abs(Math.sin(frameCounter * 0.13)) * 0.15; 
              
              let target = p3_waypoints[p3_state.targetIndex];
              let dx = target.x - p3_state.posX;
              let dy = target.y - p3_state.posY;

              if (Math.abs(dx) < p_speed && Math.abs(dy) < p_speed) {
                  p3_state.posX = target.x;
                  p3_state.posY = target.y;

                  if (p3_state.targetIndex === 3) {
                      p3_state.isPaused = true;
                      p3_state.pauseTimer = p3_pauseDuration;
                      p3_state.dir = dir_arriba; 
                      p3_state.animado = false; 
                      p3_state.hopOffset = 0.0; 
                  } else {
                      p3_state.targetIndex = (p3_state.targetIndex + 1) % p3_waypoints.length;
                      setNewTarget(p3_state, p3_waypoints);
                  }
              }
          }

          /* Lógica P4 (Bruja Naranja) */
          if (p4_state.isPaused) {
              p4_state.pauseTimer--;
              if (p4_state.pauseTimer <= 0) {
                  p4_state.isPaused = false;
                  p4_state.targetIndex = (p4_state.targetIndex + 1) % p4_waypoints.length;
                  setNewTarget(p4_state, p4_waypoints);
              }
          } else {
              p4_state.posX += p_speed * p4_state.moveDirX;
              p4_state.posY += p_speed * p4_state.moveDirY;
              
              let target = p4_waypoints[p4_state.targetIndex];
              let dx = target.x - p4_state.posX;
              let dy = target.y - p4_state.posY;

              if (Math.abs(dx) < p_speed && Math.abs(dy) < p_speed) {
                  p4_state.posX = target.x;
                  p4_state.posY = target.y;

                  if (p4_state.targetIndex === 3) {
                      p4_state.isPaused = true;
                      p4_state.pauseTimer = p4_pauseDuration;
                      p4_state.dir = dir_derecha; 
                      p4_state.animado = false; 
                  } else {
                      p4_state.targetIndex = (p4_state.targetIndex + 1) % p4_waypoints.length;
                      setNewTarget(p4_state, p4_waypoints);
                  }
              }
          }

          /* Cambio de estatua */
          if (statueCooldown > 0) statueCooldown--;
          if ((p3_state.isPaused || p4_state.isPaused) && statueCooldown === 0) {
              statueState = (statueState + 1) % 3;
              statueCooldown = 200; 
          }

          /* Lógica P6 (Mago Rojo) */
          if (p6_isPaused) {
              p6_pauseTimer--;
              if (p6_pauseTimer <= 0) {
                  p6_isPaused = false;
                  p6_dir = (p6_targetX > p6_posX) ? dir_derecha : dir_izquierda;
              }
          } else {
              p6_posX += p_speed * p6_moveDir;
              let arrived = (p6_moveDir === 1) ? (p6_posX >= p6_targetX) : (p6_posX <= p6_targetX);
              if (arrived) {
                p6_posX = p6_targetX;
                if (p6_targetX === p6_limit_right) {
                    p6_isPaused = true;
                    p6_pauseTimer = p6_pauseDuration;
                    p6_targetX = p6_stairs_X;
                    p6_moveDir = -1;
                    p6_dir = dir_derecha;
                } 
                else if (p6_targetX === p6_stairs_X) {
                    p6_isPaused = true;
                    p6_pauseTimer = p6_pauseDuration;
                    p6_dir = dir_arriba;
                    if (p6_moveDir === 1) {
                        p6_targetX = p6_limit_right;
                        p6_moveDir = 1;
                    } else {
                        p6_targetX = p6_limit_left;
                        p6_moveDir = -1;
                    }
                } 
                else if (p6_targetX === p6_limit_left) {
                    p6_isPaused = false;
                    p6_targetX = p6_stairs_X;
                    p6_moveDir = 1;
                    p6_dir = dir_derecha;
                }
              }
          }

          /* Dibujar fondo */
          gl.disable(gl.BLEND); 
          gl.bindTexture(gl.TEXTURE_2D, texFondo);
          identidad(MatrizModelo);
          escalacion(MatrizModelo, 10, 7.5, 1);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
          identidad(MatrizTextura);
          gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);
          gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
          
          /* Árbol nevado */
          if (isSnowy) {
              gl.enable(gl.BLEND);
              gl.bindTexture(gl.TEXTURE_2D, texNieve);
              identidad(MatrizModelo);
              traslacion(MatrizModelo, -3.35, 2.2, 0); 
              escalacion(MatrizModelo, 1.7, 1.9, 1.0); 
              gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
              identidad(MatrizTextura);
              traslacion(MatrizTextura, 16.0 / snowCols, 7.0 / snowRows, 0);
              escalacion(MatrizTextura, 3.0 / snowCols, 4.0 / snowRows, 1.0);
              gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);
              gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
          }

          /* Estatua */
          gl.enable(gl.BLEND); 
          gl.bindTexture(gl.TEXTURE_2D, texNieve);
          let currentStatue = statueSprites[statueState];
          identidad(MatrizModelo);
          traslacion(MatrizModelo, statuePosX, statuePosY, 0); 
          escalacion(MatrizModelo, 0.60, 1.2, 1.0); 
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
          identidad(MatrizTextura);
          traslacion(MatrizTextura, currentStatue.x / snowCols, currentStatue.y / snowRows, 0);
          escalacion(MatrizTextura, statueWidth / snowCols, statueHeight / snowRows, 1.0);
          gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);
          gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
          
          /* Decoraciones (tronco, rocas, pasto) */
          dibujarTile(3.30, -1.70, 18.3, 14.8, 1.25, 1.2, 0.7, 0.6);
          dibujarTile(-1.87, -2.20, 16.0, 13.8, 1.1, 1.2, 0.7, 0.6);
          dibujarTile(-0.80, -2.20, 16.0, 14.8, 1.1, 1.2, 0.7, 0.6);
          dibujarTile(1.40, -0.30, 16.0, 13.8, 1.1, 1.2, 0.5, 0.53);
          dibujarTile(-0.26, 0.96, 5.05, 7.9, 1.1, 1.2, 0.65, 0.53);
          dibujarTile(0.92, 0.20, 5.05, 7.9, 1.1, 1.2, 0.55, 0.53);
          dibujarTile(0.73, 1.61, 5.0, 7.9, 1.1, 1.2, 0.6, 0.53);

          /* Personajes */
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          gl.bindTexture(gl.TEXTURE_2D, texPersonajes); 

          const animFrame = Math.floor(frameCounter / 15) % 4;
          const frameSequence = [0, 1, 2, 1];
          const currentAnimFrame = frameSequence[animFrame];
          
          /* P1: Mago Azul */
          identidad(MatrizModelo);
          traslacion(MatrizModelo, p1_posX, 0.9, 0);
          escalacion(MatrizModelo, 0.5, 0.5, 1.0); 
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
          identidad(MatrizTextura);
          escalacion(MatrizTextura, 1.0 / totalTexCols, 1.0 / totalTexRows, 1.0);
          traslacion(MatrizTextura, 6 + currentAnimFrame, 4 + p1_dir_anim, 0);
          gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);
          gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

          /* P2: Mago Verde */
          identidad(MatrizModelo);
          traslacion(MatrizModelo, p2_posX, 0.9, 0);
          escalacion(MatrizModelo, 0.5, 0.5, 1.0); 
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
          identidad(MatrizTextura);
          escalacion(MatrizTextura, 1.0 / totalTexCols, 1.0 / totalTexRows, 1.0);
          traslacion(MatrizTextura, 6 + currentAnimFrame, 0 + p2_dir_anim, 0);
          gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);
          gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

          /* P3: Bruja Rosa */
          let p3_frame = p3_state.animado ? currentAnimFrame : 0;
          identidad(MatrizModelo);
          traslacion(MatrizModelo, p3_state.posX, p3_state.posY + p3_state.hopOffset, 0); 
          escalacion(MatrizModelo, 0.5, 0.5, 1.0); 
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
          identidad(MatrizTextura);
          escalacion(MatrizTextura, 1.0 / totalTexCols, 1.0 / totalTexRows, 1.0);
          traslacion(MatrizTextura, 3 + p3_frame, 4 + p3_state.dir, 0); 
          gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);
          gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
          
          /* P4: Bruja Naranja */
          let p4_frame = p4_state.animado ? currentAnimFrame : 0;
          identidad(MatrizModelo);
          traslacion(MatrizModelo, p4_state.posX, p4_state.posY, 0); 
          escalacion(MatrizModelo, 0.5, 0.5, 1.0);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
          identidad(MatrizTextura);
          escalacion(MatrizTextura, 1.0 / totalTexCols, 1.0 / totalTexRows, 1.0);
          traslacion(MatrizTextura, 3 + p4_frame, 0 + p4_state.dir, 0); 
          gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);
          gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

          /* P5: Bruja Azul */
          const spinFrame = Math.floor(frameCounter / 20) % 4;
          const spinSequence = [dir_abajo, dir_izquierda, dir_arriba, dir_derecha]; 
          const p5_current_dir = spinSequence[spinFrame];
          identidad(MatrizModelo);
          traslacion(MatrizModelo, 0.3, -1.0, 0);
          escalacion(MatrizModelo, 0.5, 0.5, 1.0);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
          identidad(MatrizTextura);
          escalacion(MatrizTextura, 1.0 / totalTexCols, 1.0 / totalTexRows, 1.0);
          traslacion(MatrizTextura, 10, 4 + p5_current_dir, 0);
          gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);
          gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

          /* P6: Mago Rojo Oscuro */
          let p6_animado = !p6_isPaused; 
          let p6_frame = p6_animado ? currentAnimFrame : 0; 
          identidad(MatrizModelo);
          traslacion(MatrizModelo, p6_posX, p6_posY, 0); 
          escalacion(MatrizModelo, 0.5, 0.5, 1.0); 
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
          identidad(MatrizTextura);
          escalacion(MatrizTextura, 1.0 / totalTexCols, 1.0 / totalTexRows, 1.0);
          traslacion(MatrizTextura, 0 + p6_frame, 0 + p6_dir, 0); 
          gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);
          gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

          gl.bindVertexArray(null); 
          requestAnimationFrame(dibuja); 
        }

        /***************************************************************************/
        /* Función principal                                                       */
        /***************************************************************************/
        function main() {
          let canvas = document.getElementById("webglcanvas");
          gl = canvas.getContext("webgl2");
          if (!gl) {
             document.write("WebGL 2.0 no está disponible"); return;
          }
          gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

          compilaEnlazaLosShaders();
          creaGeometriaRectangulo(gl);

          texFondo = leeLaTextura(gl, "fondo_escena");
          texPersonajes = leeLaTextura(gl, "hoja_sprites");
          texNieve = leeLaTextura(gl, "fondo_nieve"); 
          
          if (!texFondo || !texPersonajes || !texNieve) {
              console.error("Una o más texturas no se pudieron cargar.");
              return;
          }
          
          gl.activeTexture(gl.TEXTURE0);
          gl.useProgram(programaID);
          
          uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
          uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
          uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
          uMatrizTextura = gl.getUniformLocation(programaID, "uMatrizTextura");
          uUnidadDeTextura = gl.getUniformLocation(programaID, "uUnidadDeTextura");
          gl.uniform1i(uUnidadDeTextura, 0);

          let aspect = gl.canvas.width / canvas.height; 
          let mundoX = 5.0, mundoY = mundoX / aspect;
          ortho(MatrizProyeccion, -mundoX, mundoX, -mundoY, mundoY, -5, 5);
          gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

          identidad(MatrizVista);
          gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);

          gl.clearColor(0.0, 0.0, 0.0, 1.0); 
          //setupMouseCoordinates(gl);
          dibuja(); 
        }

        window.onload = main;

      </script>
   </body>
</html>
<!DOCTYPE html>
<head>
    <title>Pac-Man Nivel 1 - Practica 3</title>
    <style>
        body { background-color: #000; color: #fff; text-align: center; font-family: 'Press Start 2P', monospace; }
        canvas { background-color: #000; }
        #game-info { display: flex; justify-content: space-between; width: 452px; margin: 10px auto; }
        #message-area { 
            height: 60px; margin-top: 10px; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }
        #message-text { color: #ff0; }
        #restart-button {
            display: none; padding: 10px 20px; margin-top: 5px; font-family: 'Press Start 2P', monospace;
            font-size: 16px; color: #000; background-color: #ff0; border: 2px solid white; cursor: pointer;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <h1>PAC-MAN</h1>
    <div id="game-info">
        <h2 id="score">PUNTAJE: 0</h2>
        <h2 id="lives">VIDAS: 3</h2>
    </div>
    <canvas id="webglcanvas" style="border: 2px solid blue;" width="448" height="576"></canvas>
    <div id="message-area">
        <p id="message-text">PRESIONA UNA FLECHA PARA COMENZAR</p>
        <button id="restart-button">Reiniciar Juego</button>
    </div>
    <img src="sprites/wall.png" id="img_wall" hidden />
    <img src="sprites/cherry.png" id="img_cherry" hidden />
    
    <img src="sprites/pacman_cerrado.png" id="img_pac_cerrado" hidden />
    <img src="sprites/pacman_abierto.png" id="img_pac_abierto" hidden />
    
    <img src="sprites/blinky_der.png" id="img_blinky_der" hidden />
    <img src="sprites/blinky_izq.png" id="img_blinky_izq" hidden />
    <img src="sprites/blinky_arr.png" id="img_blinky_arr" hidden />
    <img src="sprites/blinky_aba.png" id="img_blinky_aba" hidden />
    <img src="sprites/pinky_der.png" id="img_pinky_der" hidden />
    <img src="sprites/pinky_izq.png" id="img_pinky_izq" hidden />
    <img src="sprites/pinky_arr.png" id="img_pinky_arr" hidden />
    <img src="sprites/pinky_aba.png" id="img_pinky_aba" hidden />
    <img src="sprites/inky_der.png" id="img_inky_der" hidden />
    <img src="sprites/inky_izq.png" id="img_inky_izq" hidden />
    <img src="sprites/inky_arr.png" id="img_inky_arr" hidden />
    <img src="sprites/inky_aba.png" id="img_inky_aba" hidden />
    <img src="sprites/clyde_der.png" id="img_clyde_der" hidden />
    <img src="sprites/clyde_izq.png" id="img_clyde_izq" hidden />
    <img src="sprites/clyde_arr.png" id="img_clyde_arr" hidden />
    <img src="sprites/clyde_aba.png" id="img_clyde_aba" hidden />
    
    <img src="sprites/fantasma_asustado.png" id="img_asustado" hidden />
    <img src="sprites/fantasma_asustado_fin.png" id="img_asustado_fin" hidden />

    <script id="vs" type="vertex">
        #version 300 es
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;

        layout(location = 0) in vec2 aVertices;
        layout(location = 1) in vec2 aCoordenadasDeTextura; // Siempre recibe coords. de textura

        out vec2 vCoordenadasDeTextura; // Siempre las pasa al fragment shader

        void main() {
            vCoordenadasDeTextura = aCoordenadasDeTextura;  
            gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
        }
    </script>
    <script id="fs" type="fragment">
        #version 300 es
        precision mediump float;
        uniform sampler2D uUnidadDeTextura;
        uniform vec4 uColor;
        uniform bool uUsaTextura;
        in vec2 vCoordenadasDeTextura;
        out vec4 color;
        void main() {
            if (uUsaTextura) {
                vec4 texColor = texture(uUnidadDeTextura, vCoordenadasDeTextura);
                if(texColor.a < 0.1) {
                    discard; 
                }
                color = texColor; 
            } else {
                color = uColor;
            }
        }
    </script>

    <script>
    /* ========================================================================= */
    /* FUNCIONES DE MATRICES Y UTILIDADES                                       */
    /* ========================================================================= */
    /* Convierte de grados a radianes */
        function toRadians(grados) {
          return grados * Math.PI / 180;
        };

        /* Matriz Identidad */
        function identidad(r) {
            r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
            r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Traslación - glTranslatef */
        function traslacion(matriz, tx, ty, tz) {
          let r = new Array(16);
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }

        /* Escalación - glScalef */
        function escalacion(matriz, sx, sy, sz) { 
          let r = new Array(16);
          r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
          r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
          r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }
	
        /* Rotación sobre Z - glRotatef */
        function rotacionZ(matriz, theta){
          let r = new Array(16);
          let c = Math.cos(toRadians(theta));
          let s = Math.sin(toRadians(theta));
          r[0] =  c; r[4] = -s; r[ 8] =  0; r[12] = 0;
          r[1] =  s; r[5] =  c; r[ 9] =  0; r[13] = 0;
          r[2] =  0; r[6] =  0; r[10] =  1; r[14] = 0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
          multiplica(matriz, matriz, r);
        }

        /* Proyección Paralela - glOrtho */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
            r[0] = 2/(der - izq); r[4] =             0; r[ 8] =                  0; r[12] =         -(der + izq)/(der - izq);
            r[1] =             0; r[5] = 2/(arr - abj); r[ 9] =                  0; r[13] =         -(arr + abj)/(arr - abj);
            r[2] =             0; r[6] =             0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
            r[3] =             0; r[7] =             0; r[11] =                  0; r[15] =                                1;
        }

        /* Multiplicación de matrices de 4 x 4 */
        function multiplica(c, a, b) {
          let r = new Array(16);
          let i, j, k;
          for (i = 0; i < 4; i++){
            for (j = 0; j < 4; j++){
              let s = 0;
              for (k = 0; k < 4; k++)
                s = s + a[i + k * 4] * b[k + j * 4];
              r[i + j * 4] = s;
            }
          }
          for (i = 0; i < 16; i++)
            c[i] = r[i];
        }
    /* ========================================================================= */
    /* LÓGICA DEL JUEGO PAC-MAN                                                  */
    /* ========================================================================= */
    let gl, uColor, uMatrizProyeccion, uMatrizVista, uMatrizModelo;
    let prog, uUnidadDeTextura, uUsaTextura;
    let MatrizProyeccion = new Array(16), MatrizVista = new Array(16), MatrizModelo = new Array(16);
    let scoreElement, livesElement, messageTextElement, restartButton;
    let paredGeo, puntoGeo, powerPillGeo, spriteGeo;
    var codigoTexturaPared, codigoFrutaCherry;
    var codigoPacmanCerrado, codigoPacmanAbierto;
    var codigoFantasmaAsustado, codigoFantasmaAsustadoFin;
    let codigosFantasmas = {};
    let sonidoInicio, sonidoWaka, sonidoMuerte, sonidoFruta, sonidoComeFantasma;
    const keys = {};
    let frameCount = 0;
    
    let juegoIniciado = false, pacmanMuriendo = false, gameOver = false, nivelCompletado = false;
    let score = 0, lives = 3, pacdotsComidos = 0, currentLifeDots = 0, totalPacDots = 0, vidaExtraConcedida = false;
    
    let modoAsustado = false, temporizadorAsustado = 0, fantasmasComidosEnCombo = 0;
    let modoGlobalFantasmas = 'scatter', temporizadorModoGlobal = 0, waveCounter = 0;
    const FPS = 60;
    const waveTimings = [
        { mode: 'scatter', duration: 7 * FPS }, { mode: 'chase', duration: 20 * FPS }, { mode: 'scatter', duration: 7 * FPS }, { mode: 'chase', duration: 20 * FPS },
        { mode: 'scatter', duration: 5 * FPS }, { mode: 'chase', duration: 20 * FPS }, { mode: 'scatter', duration: 5 * FPS }, { mode: 'chase', duration: Infinity }
    ];
    let temporizadorNivel = 0;
    let emergencyTimer = 0;

    let animacionMuerteFrame = 0;
    
    const DURACION_ANIMACION_MUERTE_FRAMES = 120; 

    const MAZE_ORIGINAL = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
        [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
        [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
        [0,0,0,0,0,1,2,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,1,0,0,0,0,0],
        [1,1,1,1,1,1,2,1,1,2,1,1,1,4,4,1,1,1,2,1,1,2,1,1,1,1,1,1],
        [0,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,0],
        [1,1,1,1,1,1,2,1,1,2,1,0,0,0,0,0,0,1,2,1,1,2,1,1,1,1,1,1],
        [0,0,0,0,0,1,2,1,1,2,1,0,0,0,0,0,0,1,2,1,1,2,1,0,0,0,0,0],
        [1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,2,2,2,1,1,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,1,1,2,2,2,1],
        [1,1,2,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,2,1,1],
        [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];
    let maze = [];
    
    const MAZE_WIDTH = MAZE_ORIGINAL[0].length;
    const MAZE_HEIGHT = MAZE_ORIGINAL.length;
    const TILE_SIZE = 1.0;
    const TUNNEL_Y = 10;

    const MAX_SPEED_PER_FRAME = 0.13;
    const PACMAN_BASE_SPEED = MAX_SPEED_PER_FRAME * 0.9; 
    const GHOST_BASE_SPEED = MAX_SPEED_PER_FRAME * 0.75;  
    
    let pacman = {};
    let ghosts = [];
    const GHOST_TARGETS = {
        blinky: { x: MAZE_WIDTH - 2, y: 0 }, pinky:  { x: 1, y: 0 },
        inky:   { x: MAZE_WIDTH - 2, y: MAZE_HEIGHT - 2 }, clyde:  { x: 1, y: MAZE_HEIGHT - 2 }
    };
    let fruit = {};

    function crearGeometria(gl, vertices, coord_textura) {
        const vao = gl.createVertexArray(); 
        gl.bindVertexArray(vao);

        const bufferVertices = gl.createBuffer(); 
        gl.bindBuffer(gl.ARRAY_BUFFER, bufferVertices);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0); 
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        // --- Lógica de UVs ---
        const bufferTextura = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, bufferTextura);
        let texCoords;
        if (coord_textura && coord_textura.length > 0) {
            texCoords = new Float32Array(coord_textura);
        } else {
            // Crea coordenadas "dummy" [0,0] si no se especifican
            texCoords = new Float32Array(vertices.length);
        }
        gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1); // Siempre habilita la location 1
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);
        // --- Fin Lógica UVs ---

        gl.bindVertexArray(null); 
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return { vao, count: vertices.length / 2 };
    }

    function leeLaTextura(imagen, codigoDeTextura) {
        gl.bindTexture(gl.TEXTURE_2D, codigoDeTextura);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        // ¡USA RGBA para soportar transparencia!
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imagen);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    }

    function cargarTexturas(callback) {
        let imagenesPorCargar = [
            // Pared y Fruta 
            { id: 'img_wall',           codigo: 'codigoTexturaPared' },
            { id: 'img_cherry',         codigo: 'codigoFrutaCherry' }, // Asumiendo que arreglarás el HTML
            // Pac-Man
            { id: 'img_pac_cerrado',    codigo: 'codigoPacmanCerrado' },
            { id: 'img_pac_abierto',    codigo: 'codigoPacmanAbierto' },
            // Fantasmas Especiales
            { id: 'img_asustado',       codigo: 'codigoFantasmaAsustado' },
            { id: 'img_asustado_fin',   codigo: 'codigoFantasmaAsustadoFin' },
            
            // Fantasmas (Usando tus IDs _der, _izq, _arr, _aba)
            { id: 'img_blinky_der',     codigo: 'blinky_derecha' },
            { id: 'img_blinky_izq',     codigo: 'blinky_izquierda' },
            { id: 'img_blinky_arr',     codigo: 'blinky_arriba' },
            { id: 'img_blinky_aba',     codigo: 'blinky_abajo' },
            
            { id: 'img_pinky_der',      codigo: 'pinky_derecha' },
            { id: 'img_pinky_izq',      codigo: 'pinky_izquierda' },
            { id: 'img_pinky_arr',      codigo: 'pinky_arriba' },
            { id: 'img_pinky_aba',      codigo: 'pinky_abajo' },
            
            { id: 'img_inky_der',       codigo: 'inky_derecha' },
            { id: 'img_inky_izq',       codigo: 'inky_izquierda' },
            { id: 'img_inky_arr',       codigo: 'inky_arriba' },
            { id: 'img_inky_aba',       codigo: 'inky_abajo' },

            { id: 'img_clyde_der',      codigo: 'clyde_derecha' },
            { id: 'img_clyde_izq',      codigo: 'clyde_izquierda' },
            { id: 'img_clyde_arr',      codigo: 'clyde_arriba' },
            { id: 'img_clyde_aba',      codigo: 'clyde_abajo' },
        ];

        let imagenesCargadas = 0;
        let nombresFantasmas = ['blinky', 'pinky', 'inky', 'clyde'];
        nombresFantasmas.forEach(n => codigosFantasmas[n] = {});

        imagenesPorCargar.forEach(imgInfo => {
            const imgElement = document.getElementById(imgInfo.id);
            if (!imgElement) {
                console.error("Error: No se encontró el elemento de imagen: " + imgInfo.id);
                return;
            }

            const textura = gl.createTexture();
            
            // Organiza las texturas
            if (nombresFantasmas.some(n => imgInfo.codigo.startsWith(n))) {
                const [nombre, dir] = imgInfo.codigo.split('_');
                codigosFantasmas[nombre][dir] = textura;
            } else {
                // Asigna a variables globales (ej. window['codigoTexturaPared'] = textura)
                window[imgInfo.codigo] = textura;
            }
            
            imgElement.onload = () => {
                leeLaTextura(imgElement, textura);
                imagenesCargadas++;
                console.log(`Cargada: ${imgInfo.id} (${imagenesCargadas}/${imagenesPorCargar.length})`);
                if (imagenesCargadas === imagenesPorCargar.length) {
                    callback(); // ¡Llama al callback cuando todas estén listas!
                }
            };
            if (imgElement.complete) {
                imgElement.onload(); // Llama manualmente si ya está en caché
            }
        });
    }

    function generarVerticesPacman(aperturaBocaGrados) {
        const numSegments = 30;
        let vertices = [0, 0];
        const anguloApertura = toRadians(aperturaBocaGrados);
        const anguloInicio = anguloApertura / 2;
        const anguloFin = (Math.PI * 2) - anguloApertura / 2;

        if (aperturaBocaGrados >= 359) return []; 

        for (let i = 0; i <= numSegments; i++) {
            const t = i / numSegments;
            const angle = anguloInicio + t * (anguloFin - anguloInicio);
            vertices.push(0.5 * Math.cos(angle), 0.5 * Math.sin(angle));
        }
        return vertices;
    }

    function isAlignedToGrid(entity) {
        const tolerance = entity.speed * 0.51;
        return (Math.abs(entity.x - Math.round(entity.x)) < tolerance) && (Math.abs(entity.y - Math.round(entity.y)) < tolerance);
    }
    
    function getTile(x, y) {
        const gridX = Math.round(x); const gridY = Math.round(y);
        if (gridY === TUNNEL_Y && (gridX < 0 || gridX >= MAZE_WIDTH)) { return 2; }
        if (gridX < 0 || gridX >= MAZE_WIDTH || gridY < 0 || gridY >= MAZE_HEIGHT) return 1;
        return maze[gridY]?.[gridX] ?? 1;
    }

    function canMove(entity, x, y, dir) {
        let nextX = Math.round(x), nextY = Math.round(y);
        if (dir === 'up') nextY--; if (dir === 'down') nextY++;
        if (dir === 'left') nextX--; if (dir === 'right') nextX++;
        const tile = getTile(nextX, nextY);
        if (tile === 1) return false;
        if (tile === 4 && entity.type === 'pacman') return false;
        if (entity.type === 'ghost' && entity.estado !== 'comido' && dir === 'down' && nextY === 9 && (nextX === 13 || nextX === 14)) return false;
        return true;
    }
    
    function getOppositeDir(dir) {
        if(dir === 'up') return 'down'; if(dir === 'down') return 'up';
        if(dir === 'left') return 'right'; if(dir === 'right') return 'left';
        return 'none';
    }

    function resetLevel() {
        pacman = { type: 'pacman', x: 14, y: 17, dir: 'none', desiredDir: 'none', baseSpeed: PACMAN_BASE_SPEED, speed: PACMAN_BASE_SPEED, rot: 90 };
        ghosts = [
            { type: 'ghost', name: 'blinky', x: 13.5, y: 9, dir: 'left', baseSpeed: GHOST_BASE_SPEED, speed: GHOST_BASE_SPEED, color: [1,0,0,1], estado: 'persiguiendo' },
            { type: 'ghost', name: 'pinky',  x: 13.5, y: 11, dir: 'up', baseSpeed: GHOST_BASE_SPEED, speed: GHOST_BASE_SPEED, color: [1,0.7,0.8,1], estado: 'enCasa' },
            { type: 'ghost', name: 'inky',   x: 11.5, y: 11, dir: 'up', baseSpeed: GHOST_BASE_SPEED, speed: GHOST_BASE_SPEED, color: [0,1,1,1], estado: 'enCasa' },
            { type: 'ghost', name: 'clyde',  x: 15.5, y: 11, dir: 'up', baseSpeed: GHOST_BASE_SPEED, speed: GHOST_BASE_SPEED, color: [1,0.7,0.2,1], estado: 'enCasa' }
        ];
        currentLifeDots = 0;
        temporizadorNivel = 0;
        emergencyTimer = 0;
        waveCounter = 0;
        temporizadorModoGlobal = waveTimings[0].duration;
        modoGlobalFantasmas = 'scatter';
    }

    function checkGhostRelease() {
        if(juegoIniciado) temporizadorNivel++;
        ghosts.forEach(ghost => {
            if (ghost.estado === 'enCasa' && ghost.releaseTimer > 0) {
                ghost.releaseTimer--;
                if (ghost.releaseTimer <= 0) ghost.estado = 'saliendo';
            }
            if(ghost.estado !== 'enCasa' || ghost.releaseTimer > 0) return;
            let sale = false;
            if (lives < 3) {
                if(ghost.name === 'pinky' && currentLifeDots >= 7) sale = true;
                if(ghost.name === 'inky' && currentLifeDots >= 17) sale = true;
                if(ghost.name === 'clyde' && currentLifeDots >= 60) sale = true;
            } else {
                if(ghost.name === 'pinky' && temporizadorNivel > 0.5 * FPS) sale = true;
                if(ghost.name === 'inky' && (temporizadorNivel > 3 * FPS || currentLifeDots >= 5)) sale = true;
                if(ghost.name === 'clyde' && (temporizadorNivel > 5 * FPS || currentLifeDots >= 15)) sale = true;
            }
            if(sale) ghost.estado = 'saliendo';
        });
        if (emergencyTimer >= 4 * FPS) {
            const preference = ['pinky', 'inky', 'clyde'];
            for (let name of preference) {
                let g = ghosts.find(g => g.name === name);
                if (g && g.estado === 'enCasa' && !(g.releaseTimer > 0)) {
                    g.estado = 'saliendo';
                    emergencyTimer = 0;
                    break;
                }
            }
        }
    }

    function actualizar() {
        if (!juegoIniciado || gameOver || pacmanMuriendo || nivelCompletado) return;
        frameCount++;
        emergencyTimer++;
        checkGhostRelease();

        if (!modoAsustado) {
            temporizadorModoGlobal--;
            if (temporizadorModoGlobal <= 0) {
                waveCounter = Math.min(waveCounter, waveTimings.length - 1);
                const currentWave = waveTimings[waveCounter];
                modoGlobalFantasmas = currentWave.mode;
                temporizadorModoGlobal = currentWave.duration;
                waveCounter++;
                ghosts.forEach(g => { if(g.estado === 'persiguiendo') g.dir = getOppositeDir(g.dir); });
            }
        }

        if (modoAsustado) {
            temporizadorAsustado--;
            if (temporizadorAsustado <= 0) {
                modoAsustado = false; fantasmasComidosEnCombo = 0;
                ghosts.forEach(ghost => { if(ghost.estado === 'asustado') ghost.estado = 'persiguiendo'; });
            }
        }
        
        pacman.speed = pacman.baseSpeed;
        
        if (isAlignedToGrid(pacman)) {
            pacman.x = Math.round(pacman.x); pacman.y = Math.round(pacman.y);
            if (pacman.desiredDir !== 'none' && canMove(pacman, pacman.x, pacman.y, pacman.desiredDir)) { pacman.dir = pacman.desiredDir; }
            if (!canMove(pacman, pacman.x, pacman.y, pacman.dir)) { pacman.dir = 'none'; }
        }
        
        if (pacman.dir !== 'none') {
            if (pacman.dir === 'up') pacman.y -= pacman.speed; if (pacman.dir === 'down') pacman.y += pacman.speed;
            if (pacman.dir === 'left') pacman.x -= pacman.speed; if (pacman.dir === 'right') pacman.x += pacman.speed;
            if (pacman.x < -1) pacman.x = MAZE_WIDTH; if (pacman.x > MAZE_WIDTH) pacman.x = -1;
            if (pacman.dir === 'up') pacman.rot = 90; if (pacman.dir === 'down') pacman.rot = -90;
            if (pacman.dir === 'left') pacman.rot = 180; if (pacman.dir === 'right') pacman.rot = 0;
            
        }

        ghosts.forEach(ghost => {
            ghost.speed = ghost.baseSpeed;
            if (ghost.estado === 'asustado') ghost.speed *= 0.5;
            if (ghost.estado === 'comido') ghost.speed *= 2.0;
            
            let finalTarget = null;
            
            switch(ghost.estado) {
                case 'enCasa': 
                    if (ghost.y <= 10.5) ghost.dir = 'down'; 
                    else if (ghost.y >= 11.5) ghost.dir = 'up'; 
                    break;
                case 'saliendo': case 'comido':
                    const targetX = 13.5, targetY = (ghost.estado === 'comido') ? 11 : 8;
                    let dx = targetX - ghost.x;
                    let dy = targetY - ghost.y;
                    if (Math.hypot(dx, dy) < 0.2) {
                        ghost.x = targetX; ghost.y = targetY;
                        if(ghost.estado === 'comido') { 
                            ghost.estado = 'enCasa'; ghost.releaseTimer = 3 * FPS; 
                        } else { 
                            ghost.estado = 'persiguiendo'; 
                            ghost.dir = (ghost.name === 'inky') ? 'right' : 'left';
                        }
                    } else {
                        if (Math.abs(dx) > 0.1) {
                            let step = Math.min(ghost.speed, Math.abs(dx));
                            ghost.x += (dx > 0 ? step : -step);
                            ghost.dir = (dx > 0) ? 'right' : 'left';
                        } else {
                            ghost.x = targetX;
                            let step = Math.min(ghost.speed, Math.abs(dy));
                            ghost.y += (dy > 0 ? step : -step);
                            ghost.dir = (dy > 0) ? 'down' : 'up';
                        }
                    }
                    break;
                default:
                    if (isAlignedToGrid(ghost)) {
                        ghost.x = Math.round(ghost.x); ghost.y = Math.round(ghost.y);
                        const oppositeDir = getOppositeDir(ghost.dir);
                        let validMoves = ['up', 'down', 'left', 'right'].filter(dir => dir !== oppositeDir && canMove(ghost, ghost.x, ghost.y, dir));
                        if (validMoves.length === 0) { validMoves = ['up', 'down', 'left', 'right'].filter(dir => canMove(ghost, ghost.x, ghost.y, dir)); }
                        let bestMove = '', finalTarget = {};
                        if(ghost.estado === 'asustado') { bestMove = validMoves[Math.floor(Math.random() * validMoves.length)]; } 
                        else {
                           if(modoGlobalFantasmas === 'scatter') finalTarget = GHOST_TARGETS[ghost.name]; 
                           else {
                                let tx, ty;
                                if(ghost.name === 'blinky') {
                                    tx = pacman.x; ty = pacman.y;
                                } else if(ghost.name === 'pinky') {
                                    tx = pacman.x; ty = pacman.y;
                                    const offset = 4;
                                    if(pacman.dir === 'up') { tx -= offset; ty -= offset; }
                                    else if(pacman.dir === 'down') { ty += offset; }
                                    else if(pacman.dir === 'left') { tx -= offset; }
                                    else if(pacman.dir === 'right') { tx += offset; }
                                } else if(ghost.name === 'inky') {
                                    let px = pacman.x, py = pacman.y;
                                    const offset = 2;
                                    if(pacman.dir === 'up') { px -= offset; py -= offset; }
                                    else if(pacman.dir === 'down') { py += offset; }
                                    else if(pacman.dir === 'left') { px -= offset; }
                                    else if(pacman.dir === 'right') { px += offset; }
                                    const blinky = ghosts[0];
                                    tx = 2 * px - blinky.x;
                                    ty = 2 * py - blinky.y;
                                } else if(ghost.name === 'clyde') {
                                    tx = pacman.x; ty = pacman.y;
                                    const dist = Math.hypot(ghost.x - tx, ghost.y - ty);
                                    if(dist <= 8) {
                                        tx = GHOST_TARGETS[ghost.name].x;
                                        ty = GHOST_TARGETS[ghost.name].y;
                                    }
                                }
                                finalTarget = {x: tx, y: ty};
                           }
                            let minDistance = Infinity;
                            for(const move of validMoves) {
                                let nX = ghost.x, nY = ghost.y;
                                if(move === 'up') nY--; if(move === 'down') nY++; if(move === 'left') nX--; if(move === 'right') nX++;
                                const dist = Math.hypot(nX - finalTarget.x, nY - finalTarget.y);
                                if(dist < minDistance) { minDistance = dist; bestMove = move; }
                            }
                        }
                        ghost.dir = bestMove || ghost.dir;
                    }
                    break;
            }
            if (ghost.estado !== 'saliendo' && ghost.estado !== 'comido') {
                if (ghost.dir === 'up') ghost.y -= ghost.speed; if (ghost.dir === 'down') ghost.y += ghost.speed;
                if (ghost.dir === 'left') ghost.x -= ghost.speed; if (ghost.dir === 'right') ghost.x += ghost.speed;
            }
            if (ghost.x < -1) ghost.x = MAZE_WIDTH; if (ghost.x > MAZE_WIDTH) ghost.x = -1;
        });

        const pacGridX = Math.round(pacman.x); const pacGridY = Math.round(pacman.y);
        const tileComido = maze[pacGridY]?.[pacGridX];
        if (tileComido === 2 || tileComido === 3) {
            score += (tileComido === 2) ? 10 : 50; totalPacDots--;
            if(tileComido === 2) {
                pacdotsComidos++;
                currentLifeDots++;
                emergencyTimer = 0;
            }
            maze[pacGridY][pacGridX] = 0; 
            scoreElement.textContent = "PUNTAJE: " + score;
            if (score >= 10000 && !vidaExtraConcedida) { lives++; vidaExtraConcedida = true; livesElement.textContent = "VIDAS: " + lives; }
            if (tileComido === 3) {
                modoAsustado = true; temporizadorAsustado = 6 * FPS; fantasmasComidosEnCombo = 0;
                ghosts.forEach(g => { if(g.estado === 'persiguiendo' || g.estado === 'asustado') { g.estado = 'asustado'; g.dir = getOppositeDir(g.dir); } });
            } else { if (sonidoWaka.paused) sonidoWaka.play(); }
        } else { if(pacman.dir !== 'none') { sonidoWaka.pause(); sonidoWaka.currentTime = 0; } }
        
        if (totalPacDots === 0) {
            nivelCompletado = true; sonidoWaka.pause();
            messageTextElement.textContent = "NIVEL COMPLETADO";
            messageTextElement.style.color = '#0f0';
            messageTextElement.style.display = 'block'; restartButton.style.display = 'block';
        }
        if (pacdotsComidos === 70 && !fruit.eaten) fruit.visible = true;
        if (fruit.visible && pacGridX === Math.round(fruit.x) && pacGridY === Math.round(fruit.y)) {
            fruit.visible = false; fruit.eaten = true; score += 100; sonidoFruta.play();scoreElement.textContent = "PUNTAJE: " + score;
        }

        ghosts.forEach(ghost => {
            if (Math.hypot(pacman.x - ghost.x, pacman.y - ghost.y) < 0.7 && !pacmanMuriendo) {
                if (ghost.estado === 'asustado') {
                    sonidoComeFantasma.play(); fantasmasComidosEnCombo++;
                    score += 200 * Math.pow(2, fantasmasComidosEnCombo - 1);
                    scoreElement.textContent = "PUNTAJE: " + score;
                    ghost.estado = 'comido';
                } else if (ghost.estado !== 'enCasa' && ghost.estado !== 'saliendo' && ghost.estado !== 'comido') {
                    animacionMuerteFrame = 0;
                    pacmanMuriendo = true;
                    sonidoWaka.pause(); sonidoMuerte.play();
                    setTimeout(() => {
                        lives--; livesElement.textContent = "VIDAS: " + lives;
                        if (lives > 0) { resetLevel(); pacmanMuriendo = false; }
                        else {
                            gameOver = true;
                            messageTextElement.textContent = "GAME OVER";
                            messageTextElement.style.color = '#f00';
                            messageTextElement.style.display = 'block';
                            restartButton.style.display = 'block';
                        }
                    }, 2000); // *** CAMBIO: Ajustado el timeout a 2000ms (2 segundos) ***
                }
            }
        });
    }
    
    function dibujar() {
        if(juegoIniciado && !pacmanMuriendo) 
            actualizar();

        gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);
        for(let y=0; y < MAZE_HEIGHT; y++){
            for(let x=0; x < MAZE_WIDTH; x++){
                const tile = maze[y]?.[x];
                if(tile === 1) { // Pared
                    dibujarObjeto(paredGeo, x, y, 1, 0, 
                        { esTextura: true, texturaID: codigoTexturaPared, escalaPared: 1.05 });
                } else if(tile === 2) { // Punto
                    dibujarObjeto(puntoGeo, x, y, 0.2, 0, 
                        { esTextura: false, color: [1, 0.8, 0.8, 1] });
                } else if(tile === 3) { // Power Pill
                    const pillScale = frameCount % 30 < 15 ? 0.5 : 0.4; 
                    dibujarObjeto(powerPillGeo, x, y, pillScale, 0, 
                        { esTextura: false, color: [1, 1, 1, 1] });
                }
            }
        }
        if(fruit.visible) { // Fruta
            dibujarObjeto(spriteGeo, fruit.x, fruit.y, 0.7, 0, 
                { esTextura: true, texturaID: codigoFrutaCherry });
        }
        ghosts.forEach(ghost => {
            if (ghost.estado === 'comido') return;

            let texturaFantasma;
            if(ghost.estado === 'asustado') {
                if (temporizadorAsustado < 2.5 * FPS && Math.floor(temporizadorAsustado / (FPS/10)) % 2 === 0) {
                    texturaFantasma = codigoFantasmaAsustadoFin;
                } else {
                    texturaFantasma = codigoFantasmaAsustado;
                }
            } else {
                let nombre = ghost.name;
                let dir;
                // ¡CAMBIO AQUÍ! Usa los nombres cortos
                switch (ghost.dir) {
                    case 'up':    dir = 'arriba'; break;
                    case 'down':  dir = 'abajo'; break;
                    case 'left':  dir = 'izquierda'; break;
                    default:      dir = 'derecha'; // Incluye 'right' y 'none'
                }
                texturaFantasma = codigosFantasmas[nombre][dir];
            }
            
            dibujarObjeto(spriteGeo, ghost.x, ghost.y, 0.9, 0, 
                { esTextura: true, texturaID: texturaFantasma });
        });

        if (!pacmanMuriendo) {
            const texturaPacman = (frameCount % 10 < 5 && pacman.dir !== 'none') 
                                  ? codigoPacmanAbierto 
                                  : codigoPacmanCerrado;
            dibujarObjeto(spriteGeo, pacman.x, pacman.y, 0.8, pacman.rot, 
                { esTextura: true, texturaID: texturaPacman });
        } else {
            animacionMuerteFrame++;
            const progreso = Math.min(animacionMuerteFrame / DURACION_ANIMACION_MUERTE_FRAMES, 1.0);
            dibujarAnimacionMuerteBoca(progreso);
        }
        if (juegoIniciado && !gameOver && !nivelCompletado) { 
            requestAnimationFrame(dibujar); 
        }
    }
    
    /* NUEVA (y única) función de dibujo */
    function dibujarObjeto(geometria, x, y, escala, rotacion, opciones) {
        
        gl.useProgram(prog); 

        if (!geometria || geometria.count === 0) return; 

        // --- Matriz Modelo ---
        identidad(MatrizModelo);
        const offsetX = -MAZE_WIDTH/2 + TILE_SIZE/2;
        const offsetY = MAZE_HEIGHT/2 - TILE_SIZE/2; // Corregí esto de tu código
        traslacion(MatrizModelo, x + offsetX, -y + offsetY, 0);
        if(rotacion !== 0) rotacionZ(MatrizModelo, rotacion);
        
        const escalaFinal = escala * (opciones.escalaPared || 1.0);
        escalacion(MatrizModelo, escalaFinal, escalaFinal, 1.0);
        
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo); 

        // --- Lógica Unificada ---
        if (opciones.esTextura) {
            gl.uniform1i(uUsaTextura, true); // 1. Activa textura
            gl.activeTexture(gl.TEXTURE0);  // 2. Configura
            gl.bindTexture(gl.TEXTURE_2D, opciones.texturaID);
            gl.uniform1i(uUnidadDeTextura, 0);
        } else {
            gl.uniform1i(uUsaTextura, false); // 1. Desactiva textura
            gl.uniform4fv(uColor, opciones.color); // 2. Configura color
        }

        // --- Dibujado ---
        gl.bindVertexArray(geometria.vao); 
        gl.drawArrays(gl.TRIANGLE_FAN, 0, geometria.count);
        gl.bindVertexArray(null);
    }

    function dibujarAnimacionMuerteBoca(progreso) {
        const anguloApertura = progreso * 360;

        const verticesMuerte = generarVerticesPacman(anguloApertura);
        const geoMuerte = crearGeometria(gl, verticesMuerte); 

        dibujarObjeto(geoMuerte, pacman.x, pacman.y, 0.8, pacman.rot,
            { esTextura: false, color: [1, 1, 0, 1] });
    }

    function iniciarJuego() {
        if (juegoIniciado) return;
        juegoIniciado = true;
        messageTextElement.style.display = 'none';
        sonidoInicio.play();
        sonidoInicio.addEventListener('ended', () => {
            requestAnimationFrame(dibujar);
        }, { once: true });
    }

    function reiniciarJuegoCompleto() {
        score = 0; lives = 3; pacdotsComidos = 0; currentLifeDots = 0;
        gameOver = false; juegoIniciado = false; pacmanMuriendo = false; nivelCompletado = false;
        fruit = {x: 13.5, y: 17, visible: false, eaten: false};
        modoAsustado = false; temporizadorAsustado = 0; vidaExtraConcedida = false;
        temporizadorNivel = 0; emergencyTimer = 0; waveCounter = 0; fantasmasComidosEnCombo = 0;

        scoreElement.textContent = "PUNTAJE: 0";
        livesElement.textContent = "VIDAS: 3";
        maze = JSON.parse(JSON.stringify(MAZE_ORIGINAL));
        totalPacDots = MAZE_ORIGINAL.flat().filter(tile => tile === 2 || tile === 3).length;
        resetLevel();

        restartButton.style.display = 'none';
        messageTextElement.textContent = "PRESIONA UNA FLECHA PARA COMENZAR";
        messageTextElement.style.color = '#ff0';
        messageTextElement.style.display = 'block';
        dibujar();
    }

    function main() {
        const canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl2");

        scoreElement = document.getElementById("score"); livesElement = document.getElementById("lives");
        messageTextElement = document.getElementById("message-text");
        restartButton = document.getElementById("restart-button");

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        // habilitar transparencia 
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        // compila shader de vertice
        let vs = gl.createShader(gl.VERTEX_SHADER); 
        gl.shaderSource(vs, document.getElementById("vs").text.trim()); 
        gl.compileShader(vs);
        // compila shader de fragmento
        let fs = gl.createShader(gl.FRAGMENT_SHADER); 
        gl.shaderSource(fs, document.getElementById("fs").text.trim()); 
        gl.compileShader(fs);
        // enlazar ambos
        prog = gl.createProgram(); 
        gl.attachShader(prog, vs); 
        gl.attachShader(prog, fs); 
        gl.linkProgram(prog); 
        gl.useProgram(prog);

        uColor = gl.getUniformLocation(prog, "uColor"); 
        uMatrizProyeccion = gl.getUniformLocation(prog, "uMatrizProyeccion");
        uMatrizVista = gl.getUniformLocation(prog, "uMatrizVista"); 
        uMatrizModelo = gl.getUniformLocation(prog, "uMatrizModelo");
        uUnidadDeTextura = gl.getUniformLocation(prog, "uUnidadDeTextura");
        uUsaTextura = gl.getUniformLocation(prog, "uUsaTextura");

        ortho(MatrizProyeccion, -MAZE_WIDTH/2, MAZE_WIDTH/2, -MAZE_HEIGHT/2, MAZE_HEIGHT/2, -1, 1);
        gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);        
        identidad(MatrizVista); gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
        
        const verticesCuadrado = [-0.5,-0.5, 0.5,-0.5, 0.5, 0.5,-0.5, 0.5];
        const texCoordsCuadrado = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];
        paredGeo = crearGeometria(gl, verticesCuadrado, texCoordsCuadrado); 
        spriteGeo = paredGeo;
        puntoGeo = crearGeometria(gl, verticesCuadrado);
        powerPillGeo = crearGeometria(gl, verticesCuadrado);
                          
        sonidoInicio = new Audio('inicio.wav'); 
        sonidoWaka = new Audio('waka.wav');
        sonidoMuerte = new Audio('muerte.wav'); 
        sonidoFruta = new Audio('fruta.wav');
        sonidoComeFantasma = new Audio('eat_ghost.wav');
        sonidoWaka.loop = true;

        window.addEventListener('keydown', (e) => {
            const dir = e.code.replace('Arrow', '').toLowerCase();
            if(['up', 'down', 'left', 'right'].includes(dir)) {
                pacman.desiredDir = dir;
                iniciarJuego();
            }
        });
        restartButton.addEventListener('click', reiniciarJuegoCompleto);

        cargarTexturas(() => {
            console.log("¡Todas las texturas cargadas! Iniciando juego.");
            reiniciarJuegoCompleto(); // ¡Ahora sí!
        });
    }
    window.onload = main;
    </script>
</body>
</html>
<!DOCTYPE HTML>
<html>
<head>
  <title>Visor 3D: Final (Texturas)</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #222; 
      margin: 0; 
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      height: 100vh;
      overflow: hidden;
    }

    #container {
      display: flex;
      background-color: white;
      padding: 10px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      border-radius: 8px;
    }

    #canvas-holder {
      border: 1px solid #555;
      margin-right: 20px;
      position: relative;
      background-color: #000; 
    }

    #ui-panel {
      width: 250px;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }

    h2 { margin-top: 0; font-size: 18px; color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px;}
    
    .control-group { margin-bottom: 15px; }
    label { display: block; font-weight: bold; margin-bottom: 5px; font-size: 14px; color: #555;}
    select, button { width: 100%; padding: 8px; margin-bottom: 5px; border-radius: 4px; border: 1px solid #ccc;}
    
    .checkbox-group { display: flex; align-items: center; margin-bottom: 15px; background: #e9ecef; padding: 10px; border-radius: 5px;}
    .checkbox-group input { margin-right: 10px; transform: scale(1.5); }
    .checkbox-group label { margin: 0; cursor: pointer; }

    button#reset { background-color: #dc3545; color: white; border: none; cursor: pointer; font-weight: bold;}
    button#reset:hover { background-color: #c82333; }

    .instructions { font-size: 12px; color: #666; background: #f8f9fa; padding: 10px; border-radius: 4px; line-height: 1.5; margin-top: auto;}
    
    #status { font-size: 11px; text-align: center; color: #007bff; margin-top: 5px; font-weight: bold; }
  </style>
</head>
<body>

  <div id="container">
    <div id="canvas-holder">
      <canvas id="webglcanvas" width="600" height="600"></canvas>
    </div>

    <div id="ui-panel">
      <h2>Panel de Control</h2>
      
      <div class="control-group">
        <label for="objectSelect">1. Seleccionar Modelo (OBJ):</label>
        <select id="objectSelect">
          <optgroup label="Modelos Sin Textura">
            <option value="Models/hoothoot.obj" data-tex="./Textures/hoothoot_tex1.png">1. Hoothoot (Plumas)</option>
          </optgroup>
          <optgroup label="Modelos Con Textura">
            <option value="Models/chicken.obj" data-tex="./Textures/chicken.png">2. Pollo</option>
            <option value="Models/druid.obj" data-tex="./Textures/druid.png">3. Druida</option>
            <option value="Models/Girl.obj" data-tex="./Textures/Atlas_Girl.png">4. Chica</option>
          </optgroup>
        </select>
        <div id="status">Esperando carga...</div>
      </div>

      <div class="control-group">
        <label for="styleSelect">2. Estilo Visual:</label>
        <select id="styleSelect">
          <option value="textured">Texturizado (Con Luz)</option>
          <option value="solid">S√≥lido (Gris + Luz)</option>
          <option value="colored">Coloreado (Plano)</option>
          <option value="wireframe">Malla (Alambre)</option>
          <option value="points">Puntos</option>
        </select>
      </div>

      <div class="checkbox-group">
        <input type="checkbox" id="animacionCheck">
        <label for="animacionCheck">Animaci√≥n</label>
      </div>
      
      <button id="reset">Reiniciar Vista</button>

      <div class="instructions">
        <strong>Interacci√≥n:</strong><br>
        üñ±Ô∏è <b>Izq:</b> Rotar (ArcBall)<br>
        üñ±Ô∏è <b>Der:</b> Mover<br>
        üñ±Ô∏è <b>Rueda:</b> Zoom<br>
      </div>
    </div>
  </div>

  <script id="vs" type="vertex">
    #version 300 es
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    uniform vec3 uAngulos; 
    
    layout(location = 0) in vec3 aVertices;
    layout(location = 1) in vec4 aColores;
    layout(location = 2) in vec3 aNormales; 
    layout(location = 3) in vec2 aTexCoords; 
    
    out vec4 vColores;
    out vec3 vNormales; 
    out vec3 vVertices; 
    out vec2 vTexCoords; 

    // Rotaci√≥n Euler para animaci√≥n
    mat4 rotacionX(float a) { float c=cos(a); float s=sin(a); return mat4(1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1); }
    mat4 rotacionY(float a) { float c=cos(a); float s=sin(a); return mat4(c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1); }
    mat4 rotacionZ(float a) { float c=cos(a); float s=sin(a); return mat4(c,s,0,0, -s,c,0,0, 0,0,1,0, 0,0,0,1); }
    
    void main() {
      vColores = aColores;
      vTexCoords = aTexCoords;
      
      mat4 matRotX = rotacionX(uAngulos.x);
      mat4 matRotY = rotacionY(uAngulos.y);
      mat4 matRotZ = rotacionZ(uAngulos.z);
      mat4 uMatrizRotacionTotal = matRotZ * matRotY * matRotX;

      mat4 uModeloFinal = uMatrizModelo * uMatrizRotacionTotal;

      // Transformar Normales para la luz
      vNormales = mat3(uMatrizVista) * mat3(uModeloFinal) * normalize(aNormales);

      vec4 vertices = uMatrizVista * uModeloFinal * vec4(aVertices, 1.0);
      vVertices = vertices.xyz / vertices.w;
      
      gl_Position = uMatrizProyeccion * vertices;
      gl_PointSize = 4.0; 
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision highp float;
    
    uniform vec3 uPosicionVista;
    uniform vec3 uPosicionLuz;
    uniform vec3 u_Ia;
    uniform vec3 u_Id;
    uniform vec3 u_Is;
    uniform vec3 u_ka;
    uniform vec3 u_kd;
    uniform vec3 u_ks;
    uniform float u_brillo;

    uniform sampler2D uSampler;
    uniform int uModoRender; 

    in vec4 vColores;
    in vec3 vNormales;
    in vec3 vVertices;
    in vec2 vTexCoords;
    
    out vec4 color;
    
    void main() {
        // --- C√ÅLCULO DE ILUMINACI√ìN PHONG ---
        vec3 N = normalize(vNormales);
        vec3 L = normalize(uPosicionLuz - vVertices);
        vec3 V = normalize(uPosicionVista - vVertices);
        vec3 H = normalize(L + V);

        float NL = max(0.0, dot(N, L));
        float NH = max(0.0, dot(N, H));

        // Luz base
        vec3 luzAmbiente = u_ka * u_Ia;
        vec3 luzDifusa = u_kd * u_Id * NL;
        vec3 luzEspecular = u_ks * u_Is * pow(NH, u_brillo);
        
        // Ajustamos el ambiente m√≠nimo para que no se vea negro total
        vec3 iluminacionTotal = max(luzAmbiente + luzDifusa + luzEspecular, 0.2); 

        if (uModoRender == 2) { 
            // === MODO TEXTURA + LUZ ===
            vec4 texColor = texture(uSampler, vTexCoords);
            // Multiplicamos: (Color de la Imagen) * (Luz calculada)
            color = vec4(texColor.rgb * iluminacionTotal, texColor.a);
        } 
        else if (uModoRender == 0) { 
            // === MODO S√ìLIDO (Gris) + LUZ ===
            color = vec4(iluminacionTotal, 1.0);
        } 
        else { 
            // === MODO COLOREADO / ALAMBRE (Sin Luz) ===
            color = vColores;
        }
    }
  </script>

  <script>
    "use strict";

    /* ================= VARIABLES GLOBALES ================= */
    let gl, canvas, programaID;
    let uMatrizModelo, uMatrizVista, uMatrizProyeccion, uAngulos, uModoRender;
    let uPosicionVista, uPosicionLuz, u_Ia, u_Id, u_Is, u_ka, u_kd, u_ks, u_brillo, uSampler;
    
    let currentVAO = null, currentVertexCount = 0, renderMode;
    let arcBall;
    let texturaID; 

    // Animaci√≥n
    const PERIODO_MOVIMIENTO = 0.0167; 
    let tiempo_real, tiempoMovimiento = PERIODO_MOVIMIENTO, inicio = Date.now();
    let animacionActiva = false, incX = 0, incY = 0, incZ = 0;
    const INCX = 0.3, INCY = 0.2, INCZ = 0.4;
    let rotX = 0, rotY = 0, rotZ = 0; 

    // Transformaciones
    let tx = 0, ty = 0, sx = 4, sy = 4, sz = 4; 
    let MatrizRotacion = new Array(16), MatrizGuardada = new Array(16), MatrizDeltaAnim = new Array(16);
    let boton_izq_presionado = false, boton_der_presionado = false;
    let MatrizModelo = new Array(16), MatrizVista = new Array(16), MatrizProyeccion = new Array(16);
    let posicionVista = [0, 0, 0], posicionLuz = [3, 3, 5]; 

    /* ================= CLASES MATEM√ÅTICAS (Docente) ================= */
    function toRadians(grados) { return grados * Math.PI / 180; };
    function identidad(r) { r.fill(0); r[0]=r[5]=r[10]=r[15]=1; }
    function multiplica(c, a, b) {
      let r = new Array(16);
      for (let i=0; i<4; i++) for (let j=0; j<4; j++) {
        let s = 0; for (let k=0; k<4; k++) s += a[i+k*4] * b[k+j*4]; r[i+j*4] = s;
      } for (let i=0; i<16; i++) c[i] = r[i];
    }
    function traslacion(m, tx, ty, tz) { let r=new Array(16); identidad(r); r[12]=tx; r[13]=ty; r[14]=tz; multiplica(m, m, r); }
    function escalacion(m, sx, sy, sz) { let r=new Array(16); identidad(r); r[0]=sx; r[5]=sy; r[10]=sz; multiplica(m, m, r); }
    function rotacionX(m, t) { let r=new Array(16); identidad(r); let c=Math.cos(toRadians(t)), s=Math.sin(toRadians(t)); r[5]=c; r[6]=s; r[9]=-s; r[10]=c; multiplica(m, m, r); }
    function rotacionY(m, t) { let r=new Array(16); identidad(r); let c=Math.cos(toRadians(t)), s=Math.sin(toRadians(t)); r[0]=c; r[2]=-s; r[8]=s; r[10]=c; multiplica(m, m, r); }
    function rotacionZ(m, t) { let r=new Array(16); identidad(r); let c=Math.cos(toRadians(t)), s=Math.sin(toRadians(t)); r[0]=c; r[4]=-s; r[1]=s; r[5]=c; multiplica(m, m, r); }
    function ortho(r, l, R, b, t, n, f) { r.fill(0); r[0]=2/(R-l); r[5]=2/(t-b); r[10]=-2/(f-n); r[12]=-(R+l)/(R-l); r[13]=-(t+b)/(t-b); r[14]=-(f+n)/(f-n); r[15]=1; }
    function multiplicaMV(c, a, b) {
        let r = new Array(3);
        r[0] = a[0] * b[0] + a[4] * b[1] + a[ 8] * b[2] + a[12]; r[1] = a[1] * b[0] + a[5] * b[1] + a[ 9] * b[2] + a[13];
        r[2] = a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14]; for (var i = 0; i < 3; i++) c[i] = r[i];
    }

    class Vector3 {
      constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
      mas(v2) { return (new Vector3(this.x + v2.x, this.y + v2.y, this.z + v2.z)); }
      menos(v2) { return (new Vector3(this.x - v2.x, this.y - v2.y, this.z - v2.z)); }
      producto_vectorial(v2) {
        let r = new Vector3();
        r.x = (this.y * v2.z) - (this.z * v2.y); r.y = (this.z * v2.x) - (this.x * v2.z); r.z = (this.x * v2.y) - (this.y * v2.x);
        return r;
      }
      producto_escalar(v2) { return (this.x * v2.x) + (this.y * v2.y) + (this.z * v2.z); }
      longitud() { return (Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)); }
      normaliza() { let l = this.longitud(); if(l>0){this.x/=l; this.y/=l; this.z/=l;} }
    }
    let Punto2f = function(x, y) { this.x = x; this.y = y; }
    class ArcBall {
      constructor(w, h) { this.Epsilon = 1.0e-5; this.U = new Vector3(); this.V = new Vector3(); this.ajusta(w, h); }
      ajusta(w, h) { this.ajustaAncho = 2.0 / (w - 1.0); this.ajustaAlto = 2.0 / (h - 1.0); }
      obtieneVector(vector, x, y) {
        let temp = new Punto2f(x, y);
        temp.x = (temp.x * this.ajustaAncho) - 1.0; temp.y = 1.0 - (temp.y * this.ajustaAlto);
        let longitud2 = (temp.x * temp.x) + (temp.y * temp.y);
        if (longitud2 > 1.0) { let norma = (1.0 / Math.sqrt(longitud2)); vector.x = temp.x * norma; vector.y = temp.y * norma; vector.z = 0.0; } 
        else { vector.x = temp.x; vector.y = temp.y; vector.z = Math.sqrt(1.0 - longitud2); }
      }
      primerPunto(x, y) { this.obtieneVector(this.U, x, y); }
      segundoPunto(x, y) {
        let q = new Cuaternion(); this.obtieneVector(this.V, x, y);
        if (q != null) { let Normal = this.U.producto_vectorial(this.V);
          if (Normal.longitud() > this.Epsilon) { q.x = Normal.x; q.y = Normal.y; q.z = Normal.z; q.w = this.U.producto_escalar(this.V); } 
          else { q.x = q.y = q.z = q.w = 0.0; } 
        } return q;
      }
    }
    class Cuaternion {
      constructor(w, x, y, z) { this.w = w; this.x = x; this.y = y; this.z = z; }
      multiplica(a, b) {
        let q = new Cuaternion(0,0,0,0);
        q.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z; q.x = a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y;
        q.y = a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x; q.z = a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w; return q;
      }
      multiplica_escalar(a, b) { let q = new Cuaternion(0,0,0,0); q.w = a.w * b; q.x = a.x * b; q.y = a.y * b; q.z = a.z * b; return q; }
      norma2() { return (this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z); }
      inverso() {
        let n = this.norma2(); if (n <= 1e-8) console.log("Error inverso");
        return this.multiplica_escalar(new Cuaternion(this.w, -this.x, -this.y, -this.z), 1 / n);
      }
      static rota2(a, q) {
        let d = (q.x * q.x) + (q.y * q.y) + (q.z * q.z) + (q.w * q.w); let s = (d > 0.0) ? (2.0 / d) : 0.0;
        a[0] = 1.0 - (q.y*q.y + q.z*q.z) * s; a[4] = (q.x*q.y - q.w*q.z) * s; a[8]  = (q.x*q.z + q.w*q.y) * s; a[12] = 0;
        a[1] = (q.x*q.y + q.w*q.z) * s; a[5] = 1.0 - (q.x*q.x + q.z*q.z) * s; a[9]  = (q.y*q.z - q.w*q.x) * s; a[13] = 0;
        a[2] = (q.x*q.z - q.w*q.y) * s; a[6] = (q.y*q.z + q.w*q.x) * s; a[10] = 1.0 - (q.x*q.x + q.y*q.y) * s; a[14] = 0;
        a[3] = 0; a[7] = 0; a[11] = 0; a[15] = 1;
      }
    }

    /* ================= PARSEADOR OBJ (TOKENIZER) ================= */
    class ParseadorOBJ {
        constructor(text) { this.cadena = text; this.indice = 0; }
        esDelimitador(c) { return (c == ' ' || c == '\t' || c == '(' || c == ')' || c == '"' || c == "'" || c == '\r'); }
        saltaDelimitadores() { while (this.indice < this.cadena.length && this.esDelimitador(this.cadena.charAt(this.indice))) { this.indice++; } }
        obtLongPalabra(pos) {
            let i = pos;
            while (i < this.cadena.length && !this.esDelimitador(this.cadena.charAt(i)) && this.cadena.charAt(i) !== '\n') { i++; }
            return i - pos;
        }
        getToken() {
            this.saltaDelimitadores();
            let n = this.obtLongPalabra(this.indice);
            if (n === 0) return null;
            let subcadena = this.cadena.substr(this.indice, n);
            this.indice += n; return subcadena.trim();
        }
        getFloat() { let t = this.getToken(); return t ? parseFloat(t) : null; }
        
        parsearPorLineas() {
            const lines = this.cadena.split('\n');
            const vertices = [], texCoordsRaw = [], indicesV = [], indicesVT = [];
            let minX = Number.MAX_VALUE, maxX = Number.MIN_VALUE, minY = Number.MAX_VALUE, maxY = Number.MIN_VALUE, minZ = Number.MAX_VALUE, maxZ = Number.MIN_VALUE;

            for (let line of lines) {
                this.cadena = line.trim(); this.indice = 0;
                let token = this.getToken();
                if (token === 'v') {
                    let x = this.getFloat(); let y = this.getFloat(); let z = this.getFloat();
                    vertices.push(x, y, z);
                    minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                    minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);
                } else if (token === 'vt') {
                    let u = this.getFloat(); let v = this.getFloat();
                    if(u!==null && v!==null) texCoordsRaw.push(u, v);
                } else if (token === 'f') {
                    let vIndicesLine = [], vtIndicesLine = [];
                    let val = this.getToken();
                    while(val != null) {
                        let parts = val.split('/');
                        let vIdx = parseInt(parts[0]) - 1;
                        let vtIdx = parts.length > 1 && parts[1] !== "" ? parseInt(parts[1]) - 1 : -1;
                        vIndicesLine.push(vIdx); vtIndicesLine.push(vtIdx);
                        val = this.getToken();
                    }
                    for(let i=1; i < vIndicesLine.length - 1; i++) {
                        indicesV.push(vIndicesLine[0], vIndicesLine[i], vIndicesLine[i+1]);
                        indicesVT.push(vtIndicesLine[0], vtIndicesLine[i], vtIndicesLine[i+1]); // Guardamos -1 si no hay
                    }
                }
            }
            return { vertices, texCoordsRaw, indicesV, indicesVT, minX, maxX, minY, maxY, minZ, maxZ };
        }
    }

    /* ================= DESEMPAQUETAR GEOMETR√çA (Flat Shading) ================= */
    function desempaquetarGeometria(verticesIn, texCoordsIn, indicesV, indicesVT, coloresIn) {
        let verticesOut = [], coloresOut = [], normalesOut = [], uvsOut = [];
        let tieneColores = (coloresIn && coloresIn.length > 0);
        let tieneTexturasObj = (indicesVT && indicesVT.length > 0 && texCoordsIn.length > 0);
        let tieneTexturasJson = (!indicesVT && texCoordsIn.length > 0);

        // Factor de repetici√≥n para la textura del b√∫ho (mientras m√°s alto, m√°s plumas peque√±as)
        const FACTOR_REPETICION = 10.0; 

        for(let i=0; i<indicesV.length; i+=3) {
            let i1 = indicesV[i], i2 = indicesV[i+1], i3 = indicesV[i+2];
            
            let v1 = new Vector3(verticesIn[i1*3], verticesIn[i1*3+1], verticesIn[i1*3+2]);
            let v2 = new Vector3(verticesIn[i2*3], verticesIn[i2*3+1], verticesIn[i2*3+2]);
            let v3 = new Vector3(verticesIn[i3*3], verticesIn[i3*3+1], verticesIn[i3*3+2]);

            // --- COLORES ---
            let c1, c2, c3;
            if (tieneColores) {
                if(coloresIn.length === verticesIn.length / 3 * 4) { 
                     c1 = [coloresIn[i1*4], coloresIn[i1*4+1], coloresIn[i1*4+2], coloresIn[i1*4+3]];
                     c2 = [coloresIn[i2*4], coloresIn[i2*4+1], coloresIn[i2*4+2], coloresIn[i2*4+3]];
                     c3 = [coloresIn[i3*4], coloresIn[i3*4+1], coloresIn[i3*4+2], coloresIn[i3*4+3]];
                } else { c1 = c2 = c3 = coloresIn; }
            } else {
                let r = Math.random(), g = Math.random(), b = Math.random();
                c1 = c2 = c3 = [r, g, b, 1.0];
            }

            // --- UVs (TEXTURAS) ---
            let uv1 = [0,0], uv2 = [0,0], uv3 = [0,0];
            
            if (tieneTexturasObj) { 
                // CASO 1: El modelo YA tiene texturas (Druida, Chica, Pollo)
                let t1 = indicesVT[i], t2 = indicesVT[i+1], t3 = indicesVT[i+2];
                if (t1 !== -1) uv1 = [texCoordsIn[t1*2], texCoordsIn[t1*2+1]];
                if (t2 !== -1) uv2 = [texCoordsIn[t2*2], texCoordsIn[t2*2+1]];
                if (t3 !== -1) uv3 = [texCoordsIn[t3*2], texCoordsIn[t3*2+1]];
            } 
            else if (tieneTexturasJson) { 
                // CASO 2: JSON con texturas
                uv1 = [texCoordsIn[i1*2], texCoordsIn[i1*2+1]];
                uv2 = [texCoordsIn[i2*2], texCoordsIn[i2*2+1]];
                uv3 = [texCoordsIn[i3*2], texCoordsIn[i3*2+1]];
            } 
            else {
                // CASO 3: NO TIENE TEXTURAS (HOOTHOOT) -> Generamos PROYECCI√ìN ESF√âRICA
                // F√≥rmula: u = atan2(z, x), v = y
                // Multiplicamos por FACTOR_REPETICION para que la textura se repita como un patr√≥n
                
                uv1 = [ 
                    (0.5 + Math.atan2(v1.z, v1.x) / (2 * Math.PI)) * FACTOR_REPETICION, 
                    (0.5 - Math.asin(v1.y / 1.5) / Math.PI) * FACTOR_REPETICION 
                ];
                uv2 = [ 
                    (0.5 + Math.atan2(v2.z, v2.x) / (2 * Math.PI)) * FACTOR_REPETICION, 
                    (0.5 - Math.asin(v2.y / 1.5) / Math.PI) * FACTOR_REPETICION 
                ];
                uv3 = [ 
                    (0.5 + Math.atan2(v3.z, v3.x) / (2 * Math.PI)) * FACTOR_REPETICION, 
                    (0.5 - Math.asin(v3.y / 1.5) / Math.PI) * FACTOR_REPETICION 
                ];
            }

            // Normales
            let U = v2.menos(v1); let V = v3.menos(v1);
            let Normal = U.producto_vectorial(V); Normal.normaliza();

            verticesOut.push(v1.x, v1.y, v1.z); normalesOut.push(Normal.x, Normal.y, Normal.z); coloresOut.push(...c1); uvsOut.push(...uv1);
            verticesOut.push(v2.x, v2.y, v2.z); normalesOut.push(Normal.x, Normal.y, Normal.z); coloresOut.push(...c2); uvsOut.push(...uv2);
            verticesOut.push(v3.x, v3.y, v3.z); normalesOut.push(Normal.x, Normal.y, Normal.z); coloresOut.push(...c3); uvsOut.push(...uv3);
        }
        return { vertices: verticesOut, normales: normalesOut, colores: coloresOut, uvs: uvsOut };
    }

    /* ================= CARGA IMAGEN ================= */
    function cargarImagenTextura(rutaImagen) {
        let imagen = new Image();
        imagen.onload = function() {
            gl.bindTexture(gl.TEXTURE_2D, texturaID);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); 
            
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imagen);
            
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        imagen.src = rutaImagen;
    }

    /* ================= CARGA MODELO (Centrado y Escalado) ================= */
    async function cargarModeloExterno(rutaArchivo, rutaTextura) {
        const statusDiv = document.getElementById('status');
        statusDiv.innerText = "Cargando " + rutaArchivo + "...";
        statusDiv.style.color = "orange";

        gl.bindTexture(gl.TEXTURE_2D, texturaID);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));

        if (rutaTextura) cargarImagenTextura(rutaTextura);

        try {
            const response = await fetch(rutaArchivo);
            if (!response.ok) throw new Error("Error HTTP: " + response.status);

            let vertices = [], indicesV = [], indicesVT = null, colores = [], texCoords = [];
            
            // Variables para rec√°lculo de l√≠mites
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            if (rutaArchivo.endsWith(".json")) {
                const data = await response.json();
                vertices = data.vertices;
                indicesV = data.indices; 
                colores = data.color || [];
                texCoords = data.texcoords || data.uvs || []; 

            } else if (rutaArchivo.endsWith(".obj")) {
                const text = await response.text();
                const parser = new ParseadorOBJ(text);
                const objData = parser.parsearPorLineas();
                vertices = objData.vertices;
                texCoords = objData.texCoordsRaw;
                indicesV = objData.indicesV;
                indicesVT = objData.indicesVT;
            }

            // No confiamos en los l√≠mites del parser, los recalculamos aqu√≠ sobre los v√©rtices finales
            for (let i = 0; i < vertices.length; i += 3) {
                let x = vertices[i];
                let y = vertices[i+1];
                let z = vertices[i+2];

                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
                if (z < minZ) minZ = z;
                if (z > maxZ) maxZ = z;
            }

            // 1. Calcular el CENTRO GEOM√âTRICO EXACTO
            let centerX = (minX + maxX) / 2.0;
            let centerY = (minY + maxY) / 2.0;
            let centerZ = (minZ + maxZ) / 2.0;

            // 2. Calcular la escala para que quepa en la pantalla (Tama√±o ~2.0)
            let tamX = maxX - minX;
            let tamY = maxY - minY;
            let tamZ = maxZ - minZ;
            let tam_max = Math.max(tamX, tamY, tamZ);
            
            // Si el modelo es un punto o est√° vac√≠o, evitar divisi√≥n por cero
            if (tam_max <= 0) tam_max = 1.0;
            
            let escala = 2.0 / tam_max;

            // 3. APLICAR: Mover al (0,0,0) y Escalar
            for (let i = 0; i < vertices.length; i += 3) {
              vertices[i]   = (vertices[i]   - centerX) * escala;
              vertices[i+1] = (vertices[i+1] - centerY) * escala;
              vertices[i+2] = (vertices[i+2] - centerZ) * escala;
            }

            const geo = desempaquetarGeometria(vertices, texCoords, indicesV, indicesVT, colores);
            crearBuffers(geo.vertices, geo.normales, geo.colores, geo.uvs);
            
            // Resetear transformaciones visuales para que aparezca centrado
            identidad(MatrizRotacion);
            identidad(MatrizGuardada);
            tx = 0; ty = 0; sx = 4; sy = 4; sz = 4; // Zoom inicial
            rotX = 0; rotY = 0; rotZ = 0;

            statusDiv.innerText = "Cargado: " + rutaArchivo;
            statusDiv.style.color = "green";

        } catch (error) {
            console.error(error);
            statusDiv.innerText = "Error (Ver consola)";
            statusDiv.style.color = "red";
            alert("Error cargando. Servidor Local requerido.");
        }
    }

    function crearBuffers(vertices, normales, colores, uvs) {
      if (currentVAO) gl.deleteVertexArray(currentVAO);
      
      let vao = gl.createVertexArray();
      gl.bindVertexArray(vao);

      let bv = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, bv);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

      let bc = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, bc);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

      let bn = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, bn);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normales), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 0, 0);

      let bt = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, bt);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(3); 
      gl.vertexAttribPointer(3, 2, gl.FLOAT, false, 0, 0);

      gl.bindVertexArray(null);
      
      currentVAO = vao;
      currentVertexCount = vertices.length / 3; 

      identidad(MatrizRotacion);
      identidad(MatrizGuardada);
      tx = 0; ty = 0; sx = 4; sy = 4; sz = 4; 
    }

    /* ================= EVENTOS ================= */
    function initEvents() {
      document.getElementById('objectSelect').addEventListener('change', function(e) { 
          let modelo = e.target.value;
          let textura = e.target.options[e.target.selectedIndex].getAttribute('data-tex');
          cargarModeloExterno(modelo, textura); 
      });

      document.getElementById('styleSelect').addEventListener('change', function(e) {
        const val = e.target.value;
        if (val === 'textured') { renderMode = gl.TRIANGLES; gl.uniform1i(uModoRender, 2); } 
        else if (val === 'solid') { renderMode = gl.TRIANGLES; gl.uniform1i(uModoRender, 0); }
        else if (val === 'colored') { renderMode = gl.TRIANGLES; gl.uniform1i(uModoRender, 1); }
        else if (val === 'wireframe') { renderMode = gl.LINES; gl.uniform1i(uModoRender, 1); }
        else if (val === 'points') { renderMode = gl.POINTS; gl.uniform1i(uModoRender, 1); }
      });

      document.getElementById('animacionCheck').addEventListener('change', function(e) {
        animacionActiva = e.target.checked;
        if (animacionActiva) { incX = INCX; incY = INCY; incZ = INCZ; } else { incX = 0; incY = 0; incZ = 0; }
      });

      document.getElementById('reset').onclick = function() {
        identidad(MatrizRotacion); identidad(MatrizGuardada);
        tx = 0; ty = 0; sx = 4; sy = 4; sz = 4;
        rotX = 0; rotY = 0; rotZ = 0;
      };

      canvas.addEventListener("mousedown", function(event) {
        let rect = canvas.getBoundingClientRect();
        let posx = event.clientX - rect.left; let posy = event.clientY - rect.top;
        if (event.button == 0) { 
          MatrizGuardada = MatrizRotacion.slice(); 
          arcBall.primerPunto(posx, posy);
          boton_izq_presionado = true;
        } else if (event.button == 2) { boton_der_presionado = true; }
      }, false);

      canvas.addEventListener("mouseup", function() { boton_izq_presionado = false; boton_der_presionado = false; }, false);
      canvas.addEventListener("mouseout", function() { boton_izq_presionado = false; boton_der_presionado = false; }, false);

      canvas.addEventListener("mousemove", function(event) {
        let rect = canvas.getBoundingClientRect();
        let posx = event.clientX - rect.left; let posy = event.clientY - rect.top;
        if (boton_izq_presionado) {
          let q = arcBall.segundoPunto(posx, posy);
          Cuaternion.rota2(MatrizRotacion, q);
          multiplica(MatrizRotacion, MatrizRotacion, MatrizGuardada); 
        } else if (boton_der_presionado) {
          posx = (posx * 10 / canvas.width) - 5; posy = (10 - posy * 10 / canvas.height) - 5;
          tx = posx; ty = posy;
        }
      }, false);

      canvas.addEventListener("wheel", function(event) {
        event.preventDefault();
        let factor = (event.deltaY > 0) ? 0.9 : 1.1;
        sx *= factor; sy *= factor; sz *= factor;
      }, { passive: false });
      canvas.oncontextmenu = function() { return false; }
    }

    /* ================= MAIN LOOP ================= */
    function dibuja() {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      identidad(MatrizModelo);
      traslacion(MatrizModelo, tx, ty, 0);
      escalacion(MatrizModelo, sx, sy, sz);
      
      // ROTACI√ìN MOUSE
      multiplica(MatrizModelo, MatrizModelo, MatrizRotacion);
      
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

      // ROTACI√ìN ANIMACI√ìN
      gl.uniform3f(uAngulos, toRadians(rotX), toRadians(rotY), toRadians(rotZ));

      gl.uniform3f(u_Ia, 0.2, 0.2, 0.2); gl.uniform3f(u_Id, 1.0, 1.0, 1.0); gl.uniform3f(u_Is, 1.0, 1.0, 1.0);
      gl.uniform3f(u_ka, 0.2, 0.2, 0.2); gl.uniform3f(u_kd, 0.85, 0.85, 0.85); gl.uniform3f(u_ks, 1.0, 1.0, 1.0); gl.uniform1f(u_brillo, 100.0);
      
      gl.uniform3fv(uPosicionVista, posicionVista);
      var pLuz = new Array(3); multiplicaMV(pLuz, MatrizVista, posicionLuz); gl.uniform3fv(uPosicionLuz, pLuz);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texturaID);
      gl.uniform1i(uSampler, 0);

      if (currentVAO) { gl.bindVertexArray(currentVAO); gl.drawArrays(renderMode, 0, currentVertexCount); gl.bindVertexArray(null); }

      let fin = Date.now(); 
      let duracion = fin - inicio; inicio = fin;
      tiempo_real = duracion / 1000.0; tiempoMovimiento = tiempoMovimiento - tiempo_real;

      if (tiempoMovimiento < 0.001) { 
        tiempoMovimiento = PERIODO_MOVIMIENTO;
        if (animacionActiva) {
            rotX += incX; rotY += incY; rotZ += incZ;
            identidad(MatrizDeltaAnim);
            rotacionX(MatrizDeltaAnim, incX); rotacionY(MatrizDeltaAnim, incY); rotacionZ(MatrizDeltaAnim, incZ);
            let Temp = new Array(16); multiplica(Temp, MatrizRotacion, MatrizDeltaAnim);
            for(let i=0; i<16; i++) MatrizRotacion[i] = Temp[i];
            if (boton_izq_presionado) { multiplica(Temp, MatrizGuardada, MatrizDeltaAnim); for(let i=0; i<16; i++) MatrizGuardada[i] = Temp[i]; }
        }
      }
      requestAnimationFrame(dibuja);
    }

    function main() {
      canvas = document.getElementById("webglcanvas");
      canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight;
      gl = canvas.getContext("webgl2"); if (!gl) return;

      initEvents();
      arcBall = new ArcBall(canvas.width, canvas.height);
      renderMode = gl.TRIANGLES;
      identidad(MatrizRotacion); identidad(MatrizGuardada);

      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0.08, 0.08, 0.08, 1.0); 

      texturaID = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texturaID);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));

      let vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, document.getElementById("vs").text.trim()); gl.compileShader(vs);
      let fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, document.getElementById("fs").text.trim()); gl.compileShader(fs);
      programaID = gl.createProgram(); gl.attachShader(programaID, vs); gl.attachShader(programaID, fs); gl.linkProgram(programaID); gl.useProgram(programaID);

      uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
      uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
      uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
      uAngulos = gl.getUniformLocation(programaID, "uAngulos");
      uModoRender = gl.getUniformLocation(programaID, "uModoRender");
      uPosicionVista = gl.getUniformLocation(programaID, "uPosicionVista");
      uPosicionLuz = gl.getUniformLocation(programaID, "uPosicionLuz");
      u_Ia = gl.getUniformLocation(programaID, "u_Ia"); u_Id = gl.getUniformLocation(programaID, "u_Id"); u_Is = gl.getUniformLocation(programaID, "u_Is");
      u_ka = gl.getUniformLocation(programaID, "u_ka"); u_kd = gl.getUniformLocation(programaID, "u_kd"); u_ks = gl.getUniformLocation(programaID, "u_ks"); u_brillo = gl.getUniformLocation(programaID, "u_brillo");
      uSampler = gl.getUniformLocation(programaID, "uSampler");

      let aspect = canvas.width / canvas.height;
      ortho(MatrizProyeccion, -5 * aspect, 5 * aspect, -5, 5, -2000, 2000);
      gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
      identidad(MatrizVista); gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
      gl.uniform1i(uModoRender, 2); 

      cargarModeloExterno("Models/hoothoot.obj", ""); 
      dibuja();
    }

    window.onload = main;
    window.onresize = function() {
        canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        let aspect = canvas.width / canvas.height;
        ortho(MatrizProyeccion, -5 * aspect, 5 * aspect, -5, 5, -2000, 2000);
        gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
        arcBall.ajusta(canvas.width, canvas.height);
    };
  </script>
</body>
</html>
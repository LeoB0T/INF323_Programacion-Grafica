<!DOCTYPE HTML>
<html>
<head>
  <title>Visor 3D: Proyecto Final Integrado</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f0f0f0; 
      margin: 0; 
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      height: 100vh;
      overflow: hidden;
    }

    #container {
      display: flex;
      background-color: white;
      padding: 10px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      border-radius: 8px;
    }

    #canvas-holder {
      border: 1px solid #555;
      margin-right: 20px;
      position: relative;
      background-color: #000; 
    }

    #ui-panel {
      width: 250px;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }

    h2 { margin-top: 0; font-size: 18px; color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px;}
    
    .control-group { margin-bottom: 15px; }
    label { display: block; font-weight: bold; margin-bottom: 5px; font-size: 14px; color: #555;}
    select, button { width: 100%; padding: 8px; margin-bottom: 5px; border-radius: 4px; border: 1px solid #ccc;}
    
    .checkbox-group { display: flex; align-items: center; margin-bottom: 15px; background: #e9ecef; padding: 10px; border-radius: 5px;}
    .checkbox-group input { margin-right: 10px; transform: scale(1.5); }
    .checkbox-group label { margin: 0; cursor: pointer; }

    button#reset { background-color: #dc3545; color: white; border: none; cursor: pointer; font-weight: bold;}
    button#reset:hover { background-color: #c82333; }

    .instructions { font-size: 12px; color: #666; background: #f8f9fa; padding: 10px; border-radius: 4px; line-height: 1.5; }
    
    #status { font-size: 11px; text-align: center; color: #007bff; margin-top: 5px; font-weight: bold; }
  </style>
</head>
<body>

  <div id="container">
    <div id="canvas-holder">
      <canvas id="webglcanvas" width="600" height="600"></canvas>
    </div>

    <div id="ui-panel">
      <h2>Panel de Control</h2>
      
      <div class="control-group">
        <label for="objectSelect">1. Seleccionar Modelo:</label>
        <select id="objectSelect">
          <optgroup label="Carpeta Models (OBJ)">
            <option value="Models/hoothoot.obj">1. Hoothoot </option>
            <option value="Models/girl.obj">2. Chica </option>
          </optgroup>
          <optgroup label="Carpeta Json">
            <option value="Json/druid.json">3. Druida</option>
            <option value="Json/chicken.json">4. Pollo</option>
          </optgroup>
        </select>
        <div id="status">Esperando carga...</div>
      </div>

      <div class="control-group">
        <label for="styleSelect">2. Estilo Visual:</label>
        <select id="styleSelect">
          <option value="solid">S√≥lido (Iluminado)</option>
          <option value="colored">Coloreado (Plano)</option>
          <option value="wireframe">Malla (Alambre)</option>
          <option value="points">Puntos</option>
        </select>
      </div>

      <div class="checkbox-group">
        <input type="checkbox" id="animacionCheck">
        <label for="animacionCheck">Animaci√≥n</label>
      </div>
      
      <button id="reset">Reiniciar Vista</button>

      <div class="instructions">
        <strong>Interacci√≥n:</strong><br>
        üñ±Ô∏è <b>Izq:</b> Rotar (ArcBall)<br>
        üñ±Ô∏è <b>Der:</b> Mover<br>
        üñ±Ô∏è <b>Rueda:</b> Zoom<br>
      </div>
    </div>
  </div>

  <script id="vs" type="vertex">
    #version 300 es
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    
    layout(location = 0) in vec3 aVertices;
    layout(location = 1) in vec4 aColores;
    layout(location = 2) in vec3 aNormales; 
    
    out vec4 vColores;
    out vec3 vNormales; 
    out vec3 vVertices; 
    
    void main() {
      vColores = aColores;
      
      // Transformaci√≥n de Normales a Coordenadas de la Vista (IluminacionCubo.html)
      vNormales = mat3(uMatrizVista) * mat3(uMatrizModelo) * normalize(aNormales);

      // Posici√≥n del v√©rtice en Coordenadas de la Vista (IluminacionCubo.html)
      vec4 vertices = uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
      vVertices = vertices.xyz / vertices.w;
      
      gl_Position = uMatrizProyeccion * vertices;
      gl_PointSize = 4.0; 
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision highp float;
    
    // Variables de Iluminaci√≥n (IluminacionCubo.html)
    uniform vec3 uPosicionVista;
    uniform vec3 uPosicionLuz;
    uniform vec3 u_Ia;
    uniform vec3 u_Id;
    uniform vec3 u_Is;
    uniform vec3 u_ka;
    uniform vec3 u_kd;
    uniform vec3 u_ks;
    uniform float u_brillo;

    uniform int uModoRender; // Controla si usamos luz o color plano

    in vec4 vColores;
    in vec3 vNormales;
    in vec3 vVertices;
    
    out vec4 color;
    
    void main() {
        if (uModoRender == 0) { // S√≥lido con Iluminaci√≥n (Phong)
            
            vec3 N = normalize(vNormales);
            vec3 L = normalize(uPosicionLuz - vVertices);
            vec3 V = normalize(uPosicionVista - vVertices);
            vec3 H = normalize(L + V);

            // Factores de Iluminaci√≥n
            float NL = max(0.0, dot(N, L));
            float NH = max(0.0, dot(N, H));

            // Componentes Phong
            vec3 luzAmbiente = u_ka * u_Ia;
            vec3 luzDifusa = u_kd * u_Id * NL;
            vec3 luzEspecular = u_ks * u_Is * pow(NH, u_brillo);

            vec3 rgb = luzAmbiente + luzDifusa + luzEspecular;
            
            color = vec4(rgb, 1.0);
            
        } else { // Coloreado (Sin luz)
            color = vColores;
        }
    }
  </script>

  <script>
    "use strict";

    /* ================= CLASES MATEM√ÅTICAS (Copiadas de los archivos del docente) ================= */
    function toRadians(grados) { return grados * Math.PI / 180; };

    class Vector3 {
      constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
      mas(v2) { return (new Vector3(this.x + v2.x, this.y + v2.y, this.z + v2.z)); }
      menos(v2) { return (new Vector3(this.x - v2.x, this.y - v2.y, this.z - v2.z)); }
      producto_vectorial(v2) {
        let r = new Vector3();
        r.x = (this.y * v2.z) - (this.z * v2.y);
        r.y = (this.z * v2.x) - (this.x * v2.z);
        r.z = (this.x * v2.y) - (this.y * v2.x);
        return r;
      }
      producto_escalar(v2) { return (this.x * v2.x) + (this.y * v2.y) + (this.z * v2.z); }
      longitud() { return (Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)); }
      normaliza() { let l = this.longitud(); if(l>0){this.x/=l; this.y/=l; this.z/=l;} }
    }

    let Punto2f = function(x, y) { this.x = x; this.y = y; }

    class ArcBall {
      constructor(w, h) { this.Epsilon = 1.0e-5; this.U = new Vector3(); this.V = new Vector3(); this.ajusta(w, h); }
      ajusta(w, h) { this.ajustaAncho = 2.0 / (w - 1.0); this.ajustaAlto = 2.0 / (h - 1.0); }
      obtieneVector(vector, x, y) {
        let temp = new Punto2f(x, y);
        temp.x = (temp.x * this.ajustaAncho) - 1.0;
        temp.y = 1.0 - (temp.y * this.ajustaAlto);
        let longitud2 = (temp.x * temp.x) + (temp.y * temp.y);
        if (longitud2 > 1.0) { let norma = (1.0 / Math.sqrt(longitud2)); vector.x = temp.x * norma; vector.y = temp.y * norma; vector.z = 0.0; } 
        else { vector.x = temp.x; vector.y = temp.y; vector.z = Math.sqrt(1.0 - longitud2); }
      }
      primerPunto(x, y) { this.obtieneVector(this.U, x, y); }
      segundoPunto(x, y) {
        let q = new Cuaternion();
        this.obtieneVector(this.V, x, y);
        if (q != null) { let Normal = this.U.producto_vectorial(this.V);
          if (Normal.longitud() > this.Epsilon) { q.x = Normal.x; q.y = Normal.y; q.z = Normal.z; q.w = this.U.producto_escalar(this.V); } 
          else { q.x = q.y = q.z = q.w = 0.0; } 
        } 
        return q;
      }
    }

    class Cuaternion {
      constructor(w, x, y, z) { this.w = w; this.x = x; this.y = y; this.z = z; }
      multiplica(a, b) {
        let q = new Cuaternion(0,0,0,0);
        q.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
        q.x = a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y;
        q.y = a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x;
        q.z = a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w;
        return q;
      }
      multiplica_escalar(a, b) { let q = new Cuaternion(0,0,0,0); q.w = a.w * b; q.x = a.x * b; q.y = a.y * b; q.z = a.z * b; return q; }
      norma2() { return (this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z); }
      inverso() {
        let n = this.norma2(); if (n <= 1e-8) console.log("Error inverso");
        return this.multiplica_escalar(new Cuaternion(this.w, -this.x, -this.y, -this.z), 1 / n);
      }
      static rota2(a, q) {
        let d = (q.x * q.x) + (q.y * q.y) + (q.z * q.z) + (q.w * q.w); let s = (d > 0.0) ? (2.0 / d) : 0.0;
        a[0] = 1.0 - (q.y*q.y + q.z*q.z) * s; a[4] = (q.x*q.y - q.w*q.z) * s; a[8]  = (q.x*q.z + q.w*q.y) * s; a[12] = 0;
        a[1] = (q.x*q.y + q.w*q.z) * s; a[5] = 1.0 - (q.x*q.x + q.z*q.z) * s; a[9]  = (q.y*q.z - q.w*q.x) * s; a[13] = 0;
        a[2] = (q.x*q.z - q.w*q.y) * s; a[6] = (q.y*q.z + q.w*q.x) * s; a[10] = 1.0 - (q.x*q.x + q.y*q.y) * s; a[14] = 0;
        a[3] = 0; a[7] = 0; a[11] = 0; a[15] = 1;
      }
    }

    /* ================= VARIABLES GLOBALES ================= */
    let gl, canvas, programaID;
    let uMatrizModelo, uMatrizVista, uMatrizProyeccion, uModoRender;
    let uPosicionVista, uPosicionLuz, u_Ia, u_Id, u_Is, u_ka, u_kd, u_ks, u_brillo;
    let currentVAO = null, currentVertexCount = 0, renderMode;
    let arcBall;

    // Animaci√≥n
    const PERIODO_MOVIMIENTO = 0.0167; 
    let tiempo_real, tiempoMovimiento = PERIODO_MOVIMIENTO, inicio = Date.now();
    let animacionActiva = false, incX = 0, incY = 0, incZ = 0;
    const INCX = 0.3, INCY = 0.2, INCZ = 0.4;

    // Transformaciones e Interacci√≥n
    let tx = 0, ty = 0, sx = 4, sy = 4, sz = 4; 
    let MatrizRotacion = new Array(16);
    let MatrizGuardada = new Array(16); // Equivalente a 'B' en CuboColorInteracci√≥n
    let MatrizDeltaAnim = new Array(16);
    let boton_izq_presionado = false, boton_der_presionado = false;

    let MatrizModelo = new Array(16), MatrizVista = new Array(16), MatrizProyeccion = new Array(16);
    let posicionVista = [0, 0, 0], posicionLuz = [3, 3, 5]; 

    /* ================= MATRICES ================= */
    function identidad(r) { r.fill(0); r[0]=r[5]=r[10]=r[15]=1; }
    function multiplica(c, a, b) {
      let r = new Array(16);
      for (let i=0; i<4; i++) for (let j=0; j<4; j++) {
        let s = 0; for (let k=0; k<4; k++) s += a[i+k*4] * b[k+j*4]; r[i+j*4] = s;
      } for (let i=0; i<16; i++) c[i] = r[i];
    }
    function traslacion(m, tx, ty, tz) { let r=new Array(16); identidad(r); r[12]=tx; r[13]=ty; r[14]=tz; multiplica(m, m, r); }
    function escalacion(m, sx, sy, sz) { let r=new Array(16); identidad(r); r[0]=sx; r[5]=sy; r[10]=sz; multiplica(m, m, r); }
    function rotacionX(m, t) { let r=new Array(16); identidad(r); let c=Math.cos(toRadians(t)), s=Math.sin(toRadians(t)); r[5]=c; r[6]=s; r[9]=-s; r[10]=c; multiplica(m, m, r); }
    function rotacionY(m, t) { let r=new Array(16); identidad(r); let c=Math.cos(toRadians(t)), s=Math.sin(toRadians(t)); r[0]=c; r[2]=-s; r[8]=s; r[10]=c; multiplica(m, m, r); }
    function rotacionZ(m, t) { let r=new Array(16); identidad(r); let c=Math.cos(toRadians(t)), s=Math.sin(toRadians(t)); r[0]=c; r[4]=-s; r[1]=s; r[5]=c; multiplica(m, m, r); }
    function ortho(r, l, R, b, t, n, f) { r.fill(0); r[0]=2/(R-l); r[5]=2/(t-b); r[10]=-2/(f-n); r[12]=-(R+l)/(R-l); r[13]=-(t+b)/(t-b); r[14]=-(f+n)/(f-n); r[15]=1; }
    function multiplicaMV(c, a, b) {
        let r = new Array(3);
        r[0] = a[0] * b[0] + a[4] * b[1] + a[ 8] * b[2] + a[12]; r[1] = a[1] * b[0] + a[5] * b[1] + a[ 9] * b[2] + a[13];
        r[2] = a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14]; for (var i = 0; i < 3; i++) c[i] = r[i];
    }

    /* ================= CLASE PARSEADOR OBJ (Basada en LeeObjMalla.html) ================= */
    class ParseadorOBJ {
        constructor(text) {
            this.cadena = text;
            this.indice = 0;
        }
        esDelimitador(c) { return (c == ' ' || c == '\t' || c == '(' || c == ')' || c == '"' || c == "'" || c == '\r'); }
        saltaDelimitadores() {
            while (this.indice < this.cadena.length && this.esDelimitador(this.cadena.charAt(this.indice))) { this.indice++; }
        }
        obtLongPalabra(pos) {
            let i = pos;
            while (i < this.cadena.length && !this.esDelimitador(this.cadena.charAt(i)) && this.cadena.charAt(i) !== '\n') { i++; }
            return i - pos;
        }
        getToken() {
            this.saltaDelimitadores();
            let n = this.obtLongPalabra(this.indice);
            if (n === 0) return null;
            let subcadena = this.cadena.substr(this.indice, n);
            this.indice += n; 
            return subcadena.trim();
        }
        getInt() { let t = this.getToken(); return t ? parseInt(t, 10) : null; }
        getFloat() { let t = this.getToken(); return t ? parseFloat(t) : null; }
        
        parsearPorLineas() {
            const lines = this.cadena.split('\n');
            const vertices = [];
            const indices = [];
            let minX = Number.MAX_VALUE, maxX = Number.MIN_VALUE;
            let minY = Number.MAX_VALUE, maxY = Number.MIN_VALUE;
            let minZ = Number.MAX_VALUE, maxZ = Number.MIN_VALUE;

            for (let line of lines) {
                this.cadena = line.trim(); 
                this.indice = 0;
                let token = this.getToken();
                
                if (token === 'v') {
                    let x = this.getFloat(); let y = this.getFloat(); let z = this.getFloat();
                    vertices.push(x, y, z);
                    minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                    minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);
                } else if (token === 'f') {
                    let vIndices = [];
                    let val = this.getToken();
                    while(val != null) {
                        let vIndex = parseInt(val.split('/')[0]) - 1;
                        vIndices.push(vIndex);
                        val = this.getToken();
                    }
                    // Triangulaci√≥n (Triangle Fan)
                    for(let i=1; i < vIndices.length - 1; i++) {
                        indices.push(vIndices[0], vIndices[i], vIndices[i+1]);
                    }
                }
            }
            return { vertices, indices, minX, maxX, minY, maxY, minZ, maxZ };
        }
    }

    /* ================= MANEJO GEOMETR√çA (Para Sombreado Plano) ================= */
    function desempaquetarGeometria(verticesIn, indicesIn, coloresIn) {
        let verticesOut = [], coloresOut = [], normalesOut = [];
        let tieneColores = (coloresIn && coloresIn.length > 0);

        for(let i=0; i<indicesIn.length; i+=3) {
            let i1 = indicesIn[i], i2 = indicesIn[i+1], i3 = indicesIn[i+2];
            let v1 = new Vector3(verticesIn[i1*3], verticesIn[i1*3+1], verticesIn[i1*3+2]);
            let v2 = new Vector3(verticesIn[i2*3], verticesIn[i2*3+1], verticesIn[i2*3+2]);
            let v3 = new Vector3(verticesIn[i3*3], verticesIn[i3*3+1], verticesIn[i3*3+2]);

            // C√°lculo de color por cara (Low Poly)
            let c1, c2, c3;
            if (tieneColores) {
                if(coloresIn.length === verticesIn.length / 3 * 4) { 
                     c1 = [coloresIn[i1*4], coloresIn[i1*4+1], coloresIn[i1*4+2], coloresIn[i1*4+3]];
                     c2 = [coloresIn[i2*4], coloresIn[i2*4+1], coloresIn[i2*4+2], coloresIn[i2*4+3]];
                     c3 = [coloresIn[i3*4], coloresIn[i3*4+1], coloresIn[i3*4+2], coloresIn[i3*4+3]];
                } else { // Color √∫nico global
                     c1 = c2 = c3 = coloresIn; 
                }
            } else {
                let r = Math.random(), g = Math.random(), b = Math.random();
                c1 = [r, g, b, 1.0]; c2 = [r, g, b, 1.0]; c3 = [r, g, b, 1.0];
            }

            // C√°lculo de Normal Plana (Flat Shading)
            let U = v2.menos(v1); let V = v3.menos(v1);
            let Normal = U.producto_vectorial(V); Normal.normaliza();

            verticesOut.push(v1.x, v1.y, v1.z); normalesOut.push(Normal.x, Normal.y, Normal.z); coloresOut.push(...c1);
            verticesOut.push(v2.x, v2.y, v2.z); normalesOut.push(Normal.x, Normal.y, Normal.z); coloresOut.push(...c2);
            verticesOut.push(v3.x, v3.y, v3.z); normalesOut.push(Normal.x, Normal.y, Normal.z); coloresOut.push(...c3);
        }
        return { vertices: verticesOut, normales: normalesOut, colores: coloresOut };
    }

    /* ================= CARGA EXTERNA NORMALIZADA ================= */
    async function cargarModeloExterno(rutaArchivo) {
        const statusDiv = document.getElementById('status');
        statusDiv.innerText = "Cargando " + rutaArchivo + "...";
        statusDiv.style.color = "orange";

        try {
            const response = await fetch(rutaArchivo);
            if (!response.ok) throw new Error("Error HTTP: " + response.status);

            let vertices = [], indices = [], colores = [];
            let minX, maxX, minY, maxY, minZ, maxZ;

            if (rutaArchivo.endsWith(".json")) {
                const data = await response.json();
                vertices = data.vertices;
                indices = data.indices;
                colores = data.color || [];
                
                minX = Number.MAX_VALUE; maxX = Number.MIN_VALUE;
                minY = Number.MAX_VALUE; maxY = Number.MIN_VALUE;
                minZ = Number.MAX_VALUE; maxZ = Number.MIN_VALUE;
                for(let i=0; i<vertices.length; i+=3) {
                    let x = vertices[i], y = vertices[i+1], z = vertices[i+2];
                    minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                    minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);
                }

            } else if (rutaArchivo.endsWith(".obj")) {
                const text = await response.text();
                const parser = new ParseadorOBJ(text);
                const objData = parser.parsearPorLineas();
                vertices = objData.vertices;
                indices = objData.indices;
                minX = objData.minX; maxX = objData.maxX;
                minY = objData.minY; maxY = objData.maxY;
                minZ = objData.minZ; maxZ = objData.maxZ;
            }

            // === NORMALIZACI√ìN (LeeObjMalla.html) ===
            let tam_max = 0;
            tam_max = Math.max(tam_max, maxX - minX);
            tam_max = Math.max(tam_max, maxY - minY);
            tam_max = Math.max(tam_max, maxZ - minZ);
            let escala = 2.0 / tam_max;

            for (let i = 0; i < vertices.length; i += 3) {
              vertices[i]   = escala * (vertices[i]   - minX) - 1.0;
              vertices[i+1] = escala * (vertices[i+1] - minY) - 1.0;
              vertices[i+2] = escala * (vertices[i+2] - minZ) - 1.0;
            }

            const geo = desempaquetarGeometria(vertices, indices, colores);
            crearBuffers(geo.vertices, geo.normales, geo.colores);
            
            statusDiv.innerText = "Cargado: " + rutaArchivo;
            statusDiv.style.color = "green";
        } catch (error) {
            console.error(error);
            statusDiv.innerText = "Error (Ver consola)";
            statusDiv.style.color = "red";
            alert("Error cargando. Servidor Local requerido.");
        }
    }

    function crearBuffers(vertices, normales, colores) {
      if (currentVAO) gl.deleteVertexArray(currentVAO);
      
      let vao = gl.createVertexArray();
      gl.bindVertexArray(vao);

      let bv = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, bv);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

      let bc = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, bc);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

      let bn = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, bn);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normales), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 0, 0);

      gl.bindVertexArray(null);
      
      currentVAO = vao;
      currentVertexCount = vertices.length / 3; 

      identidad(MatrizRotacion);
      identidad(MatrizGuardada);
      tx = 0; ty = 0; sx = 4; sy = 4; sz = 4; 
    }

    /* ================= EVENTOS (Logica de CuboColorInteraccion...) ================= */
    function initEvents() {
      document.getElementById('objectSelect').addEventListener('change', function(e) { 
          cargarModeloExterno(e.target.value); 
      });

      document.getElementById('styleSelect').addEventListener('change', function(e) {
        const val = e.target.value;
        if (val === 'solid') { renderMode = gl.TRIANGLES; gl.uniform1i(uModoRender, 0); }
        else if (val === 'colored') { renderMode = gl.TRIANGLES; gl.uniform1i(uModoRender, 1); }
        else if (val === 'wireframe') { renderMode = gl.LINES; gl.uniform1i(uModoRender, 1); }
        else if (val === 'points') { renderMode = gl.POINTS; gl.uniform1i(uModoRender, 1); }
      });

      document.getElementById('animacionCheck').addEventListener('change', function(e) {
        animacionActiva = e.target.checked;
        if (animacionActiva) { incX = INCX; incY = INCY; incZ = INCZ; } else { incX = 0; incY = 0; incZ = 0; }
      });

      document.getElementById('reset').onclick = function() {
        identidad(MatrizRotacion);
        identidad(MatrizGuardada);
        tx = 0; ty = 0; sx = 4; sy = 4; sz = 4;
      };

      canvas.addEventListener("mousedown", function(event) {
        let rect = canvas.getBoundingClientRect();
        let posx = event.clientX - rect.left;
        let posy = event.clientY - rect.top;
        if (event.button == 0) { 
          MatrizGuardada = MatrizRotacion.slice(); // Copia 'B'
          arcBall.primerPunto(posx, posy);
          boton_izq_presionado = true;
        } else if (event.button == 2) { boton_der_presionado = true; }
      }, false);

      canvas.addEventListener("mouseup", function() { boton_izq_presionado = false; boton_der_presionado = false; }, false);
      canvas.addEventListener("mouseout", function() { boton_izq_presionado = false; boton_der_presionado = false; }, false);

      canvas.addEventListener("mousemove", function(event) {
        let rect = canvas.getBoundingClientRect();
        let posx = event.clientX - rect.left;
        let posy = event.clientY - rect.top;
        if (boton_izq_presionado) {
          let q = arcBall.segundoPunto(posx, posy);
          Cuaternion.rota2(MatrizRotacion, q);
          multiplica(MatrizRotacion, MatrizRotacion, MatrizGuardada); // Matriz = Rot * B
        } else if (boton_der_presionado) {
          posx = (posx * 10 / canvas.width) - 5; posy = (10 - posy * 10 / canvas.height) - 5;
          tx = posx; ty = posy;
        }
      }, false);

      canvas.addEventListener("wheel", function(event) {
        event.preventDefault();
        let factor = (event.deltaY > 0) ? 0.9 : 1.1;
        sx *= factor; sy *= factor; sz *= factor;
      }, { passive: false });
      canvas.oncontextmenu = function() { return false; }
    }

    /* ================= MAIN LOOP ================= */
    function dibuja() {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      identidad(MatrizModelo);
      traslacion(MatrizModelo, tx, ty, 0);
      escalacion(MatrizModelo, sx, sy, sz);
      multiplica(MatrizModelo, MatrizModelo, MatrizRotacion);
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

      // Configuraci√≥n de Iluminaci√≥n (IluminacionCubo.html)
      gl.uniform3f(u_Ia, 0.2, 0.2, 0.2); gl.uniform3f(u_Id, 1.0, 1.0, 1.0); gl.uniform3f(u_Is, 1.0, 1.0, 1.0);
      gl.uniform3f(u_ka, 0.2, 0.2, 0.2); gl.uniform3f(u_kd, 0.85, 0.85, 0.85); gl.uniform3f(u_ks, 1.0, 1.0, 1.0); gl.uniform1f(u_brillo, 100.0);
      
      gl.uniform3fv(uPosicionVista, posicionVista);
      var pLuz = new Array(3); multiplicaMV(pLuz, MatrizVista, posicionLuz); gl.uniform3fv(uPosicionLuz, pLuz);

      if (currentVAO) { gl.bindVertexArray(currentVAO); gl.drawArrays(renderMode, 0, currentVertexCount); gl.bindVertexArray(null); }

      let fin = Date.now(); 
      let duracion = fin - inicio; inicio = fin;
      tiempo_real = duracion / 1000.0; tiempoMovimiento = tiempoMovimiento - tiempo_real;

      if (tiempoMovimiento < 0.001) { 
        tiempoMovimiento = PERIODO_MOVIMIENTO;
        if (animacionActiva) {
            identidad(MatrizDeltaAnim);
            rotacionX(MatrizDeltaAnim, incX); rotacionY(MatrizDeltaAnim, incY); rotacionZ(MatrizDeltaAnim, incZ);
            let Temp = new Array(16); multiplica(Temp, MatrizRotacion, MatrizDeltaAnim);
            for(let i=0; i<16; i++) MatrizRotacion[i] = Temp[i];
            // Actualizamos la matriz base tambi√©n para que el mouse no "salte"
            if (boton_izq_presionado) { multiplica(Temp, MatrizGuardada, MatrizDeltaAnim); for(let i=0; i<16; i++) MatrizGuardada[i] = Temp[i]; }
        }
      }
      requestAnimationFrame(dibuja);
    }

    function main() {
      canvas = document.getElementById("webglcanvas");
      canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight;
      gl = canvas.getContext("webgl2"); if (!gl) return;

      initEvents();
      arcBall = new ArcBall(canvas.width, canvas.height);
      renderMode = gl.TRIANGLES;
      identidad(MatrizRotacion); identidad(MatrizGuardada);

      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0.08, 0.08, 0.08, 1.0); 

      let vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, document.getElementById("vs").text.trim()); gl.compileShader(vs);
      let fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, document.getElementById("fs").text.trim()); gl.compileShader(fs);
      programaID = gl.createProgram(); gl.attachShader(programaID, vs); gl.attachShader(programaID, fs); gl.linkProgram(programaID); gl.useProgram(programaID);

      uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
      uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
      uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
      uModoRender = gl.getUniformLocation(programaID, "uModoRender");
      uPosicionVista = gl.getUniformLocation(programaID, "uPosicionVista");
      uPosicionLuz = gl.getUniformLocation(programaID, "uPosicionLuz");
      u_Ia = gl.getUniformLocation(programaID, "u_Ia"); u_Id = gl.getUniformLocation(programaID, "u_Id"); u_Is = gl.getUniformLocation(programaID, "u_Is");
      u_ka = gl.getUniformLocation(programaID, "u_ka"); u_kd = gl.getUniformLocation(programaID, "u_kd"); u_ks = gl.getUniformLocation(programaID, "u_ks"); u_brillo = gl.getUniformLocation(programaID, "u_brillo");

      let aspect = canvas.width / canvas.height;
      ortho(MatrizProyeccion, -5 * aspect, 5 * aspect, -5, 5, -2000, 2000);
      gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
      identidad(MatrizVista); gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
      gl.uniform1i(uModoRender, 0); 

      cargarModeloExterno("Models/hoothoot.obj");
      dibuja();
    }

    window.onload = main;
    window.onresize = function() {
        canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        let aspect = canvas.width / canvas.height;
        ortho(MatrizProyeccion, -5 * aspect, 5 * aspect, -5, 5, -2000, 2000);
        gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
        arcBall.ajusta(canvas.width, canvas.height);
    };
  </script>
</body>
</html>